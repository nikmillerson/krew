{"version":"2.1.0","$schema":"https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json","runs":[{"tool":{"driver":{"name":"Staticcheck","version":"2025.1.1","informationUri":"https://staticcheck.dev","rules":[{"id":"SA9004","shortDescription":{"text":"Only the first constant has an explicit type","markdown":"Only the first constant has an explicit type"},"help":{"text":"Only the first constant has an explicit type\n\nIn a constant declaration such as the following:\n\n```go\nconst (\n    First byte = 1\n    Second     = 2\n)\n```\n\nthe constant Second does not have the same type as the constant First. This construct shouldn't be confused with\n\n```go\nconst (\n    First byte = iota\n    Second\n)\n```\n\nwhere First and Second do indeed have the same type. The type is only passed on when no explicit value is assigned to the constant.\n\nWhen declaring enumerations with explicit values it is therefore important not to write\n\n```go\nconst (\n      EnumFirst EnumType = 1\n      EnumSecond         = 2\n      EnumThird          = 3\n)\n```\n\nThis discrepancy in types can cause various confusing behaviors and bugs.\n\n\n## Wrong type in variable declarations\n\nThe most obvious issue with such incorrect enumerations expresses itself as a compile error:\n\n```go\npackage pkg\n\nconst (\n    EnumFirst  uint8 = 1\n    EnumSecond       = 2\n)\n\nfunc fn(useFirst bool) {\n    x := EnumSecond\n    if useFirst {\n        x = EnumFirst\n    }\n}\n```\n\nfails to compile with\n\n```go\n./const.go:11:5: cannot use EnumFirst (type uint8) as type int in assignment\n```\n\n\n## Losing method sets\n\nA more subtle issue occurs with types that have methods and optional interfaces. Consider the following:\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Enum int\n\nfunc (e Enum) String() string {\n    return \"an enum\"\n}\n\nconst (\n    EnumFirst  Enum = 1\n    EnumSecond      = 2\n)\n\nfunc main() {\n    fmt.Println(EnumFirst)\n    fmt.Println(EnumSecond)\n}\n```\n\nThis code will output\n\n```go\nan enum\n2\n```\n\nas EnumSecond has no explicit type, and thus defaults to int.\n\n\n","markdown":"Only the first constant has an explicit type\n\nIn a constant declaration such as the following:\n\n```go\nconst (\n    First byte = 1\n    Second     = 2\n)\n```\n\nthe constant Second does not have the same type as the constant First. This construct shouldn't be confused with\n\n```go\nconst (\n    First byte = iota\n    Second\n)\n```\n\nwhere `First` and `Second` do indeed have the same type. The type is only passed on when no explicit value is assigned to the constant.\n\nWhen declaring enumerations with explicit values it is therefore important not to write\n\n```go\nconst (\n      EnumFirst EnumType = 1\n      EnumSecond         = 2\n      EnumThird          = 3\n)\n```\n\nThis discrepancy in types can cause various confusing behaviors and bugs.\n\n\n## Wrong type in variable declarations\n\nThe most obvious issue with such incorrect enumerations expresses itself as a compile error:\n\n```go\npackage pkg\n\nconst (\n    EnumFirst  uint8 = 1\n    EnumSecond       = 2\n)\n\nfunc fn(useFirst bool) {\n    x := EnumSecond\n    if useFirst {\n        x = EnumFirst\n    }\n}\n```\n\nfails to compile with\n\n```go\n./const.go:11:5: cannot use EnumFirst (type uint8) as type int in assignment\n```\n\n\n## Losing method sets\n\nA more subtle issue occurs with types that have methods and optional interfaces. Consider the following:\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype Enum int\n\nfunc (e Enum) String() string {\n    return \"an enum\"\n}\n\nconst (\n    EnumFirst  Enum = 1\n    EnumSecond      = 2\n)\n\nfunc main() {\n    fmt.Println(EnumFirst)\n    fmt.Println(EnumSecond)\n}\n```\n\nThis code will output\n\n```go\nan enum\n2\n```\n\nas `EnumSecond` has no explicit type, and thus defaults to `int`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9004","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5002","shortDescription":{"text":"The empty for loop ('for {}') spins and can block the scheduler","markdown":"The empty for loop (`for {}`) spins and can block the scheduler"},"help":{"text":"The empty for loop ('for {}') spins and can block the scheduler\n\n\n","markdown":"The empty for loop (`for {}`) spins and can block the scheduler\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5002","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5005","shortDescription":{"text":"The finalizer references the finalized object, preventing garbage collection","markdown":"The finalizer references the finalized object, preventing garbage collection"},"help":{"text":"The finalizer references the finalized object, preventing garbage collection\n\nA finalizer is a function associated with an object that runs when the garbage collector is ready to collect said object, that is when the object is no longer referenced by anything.\n\nIf the finalizer references the object, however, it will always remain as the final reference to that object, preventing the garbage collector from collecting the object. The finalizer will never run, and the object will never be collected, leading to a memory leak. That is why the finalizer should instead use its first argument to operate on the object. That way, the number of references can temporarily go to zero before the object is being passed to the finalizer.\n\n\n","markdown":"The finalizer references the finalized object, preventing garbage collection\n\nA finalizer is a function associated with an object that runs when the garbage collector is ready to collect said object, that is when the object is no longer referenced by anything.\n\nIf the finalizer references the object, however, it will always remain as the final reference to that object, preventing the garbage collector from collecting the object. The finalizer will never run, and the object will never be collected, leading to a memory leak. That is why the finalizer should instead use its first argument to operate on the object. That way, the number of references can temporarily go to zero before the object is being passed to the finalizer.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1006","shortDescription":{"text":"Poorly chosen receiver name","markdown":"Poorly chosen receiver name"},"help":{"text":"Poorly chosen receiver name\n\nQuoting Go Code Review Comments:\n\n\u003e The name of a method's receiver should be a reflection of its\n\u003e identity; often a one or two letter abbreviation of its type\n\u003e suffices (such as \"c\" or \"cl\" for \"Client\"). Don't use generic\n\u003e names such as \"me\", \"this\" or \"self\", identifiers typical of\n\u003e object-oriented languages that place more emphasis on methods as\n\u003e opposed to functions. The name need not be as descriptive as that\n\u003e of a method argument, as its role is obvious and serves no\n\u003e documentary purpose. It can be very short as it will appear on\n\u003e almost every line of every method of the type; familiarity admits\n\u003e brevity. Be consistent, too: if you call the receiver \"c\" in one\n\u003e method, don't call it \"cl\" in another.\n\n\n","markdown":"Poorly chosen receiver name\n\nQuoting Go Code Review Comments:\n\n\u003e The name of a method's receiver should be a reflection of its\n\u003e identity; often a one or two letter abbreviation of its type\n\u003e suffices (such as \"c\" or \"cl\" for \"Client\"). Don't use generic\n\u003e names such as \"me\", \"this\" or \"self\", identifiers typical of\n\u003e object-oriented languages that place more emphasis on methods as\n\u003e opposed to functions. The name need not be as descriptive as that\n\u003e of a method argument, as its role is obvious and serves no\n\u003e documentary purpose. It can be very short as it will appear on\n\u003e almost every line of every method of the type; familiarity admits\n\u003e brevity. Be consistent, too: if you call the receiver \"c\" in one\n\u003e method, don't call it \"cl\" in another.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1011","shortDescription":{"text":"Use a single append to concatenate two slices","markdown":"Use a single `append` to concatenate two slices"},"help":{"text":"Use a single append to concatenate two slices\n\nBefore:\n\n```go\nfor _, e := range y {\n    x = append(x, e)\n}\n\nfor i := range y {\n    x = append(x, y[i])\n}\n\nfor i := range y {\n    v := y[i]\n    x = append(x, v)\n}\n```\n\nAfter:\n\n```go\nx = append(x, y...)\nx = append(x, y...)\nx = append(x, y...)\n```\n\n\n","markdown":"Use a single `append` to concatenate two slices\n\nBefore:\n\n```go\nfor _, e := range y {\n    x = append(x, e)\n}\n\nfor i := range y {\n    x = append(x, y[i])\n}\n\nfor i := range y {\n    v := y[i]\n    x = append(x, v)\n}\n```\n\nAfter:\n\n```go\nx = append(x, y...)\nx = append(x, y...)\nx = append(x, y...)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1011","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1004","shortDescription":{"text":"Replace call to bytes.Compare with bytes.Equal","markdown":"Replace call to `bytes.Compare` with `bytes.Equal`"},"help":{"text":"Replace call to bytes.Compare with bytes.Equal\n\nBefore:\n\n```go\nif bytes.Compare(x, y) == 0 {}\n```\n\nAfter:\n\n```go\nif bytes.Equal(x, y) {}\n```\n\n\n","markdown":"Replace call to `bytes.Compare` with `bytes.Equal`\n\nBefore:\n\n```go\nif bytes.Compare(x, y) == 0 {}\n```\n\nAfter:\n\n```go\nif bytes.Equal(x, y) {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1004","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4009","shortDescription":{"text":"A function argument is overwritten before its first use","markdown":"A function argument is overwritten before its first use"},"help":{"text":"A function argument is overwritten before its first use\n\n\n","markdown":"A function argument is overwritten before its first use\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4009","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1039","shortDescription":{"text":"Unnecessary use of fmt.Sprint","markdown":"Unnecessary use of `fmt.Sprint`"},"help":{"text":"Unnecessary use of fmt.Sprint\n\nCalling fmt.Sprint with a single string argument is unnecessary and identical to using the string directly.\n\n\n","markdown":"Unnecessary use of `fmt.Sprint`\n\nCalling `fmt.Sprint` with a single string argument is unnecessary and identical to using the string directly.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1039","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA2001","shortDescription":{"text":"Empty critical section, did you mean to defer the unlock?","markdown":"Empty critical section, did you mean to defer the unlock?"},"help":{"text":"Empty critical section, did you mean to defer the unlock?\n\nEmpty critical sections of the kind\n\n```go\nmu.Lock()\nmu.Unlock()\n```\n\nare very often a typo, and the following was intended instead:\n\n```go\nmu.Lock()\ndefer mu.Unlock()\n```\n\nDo note that sometimes empty critical sections can be useful, as a form of signaling to wait on another goroutine. Many times, there are simpler ways of achieving the same effect. When that isn't the case, the code should be amply commented to avoid confusion. Combining such comments with a //lint:ignore directive can be used to suppress this rare false positive.\n\n\n","markdown":"Empty critical section, did you mean to defer the unlock?\n\nEmpty critical sections of the kind\n\n```go\nmu.Lock()\nmu.Unlock()\n```\n\nare very often a typo, and the following was intended instead:\n\n```go\nmu.Lock()\ndefer mu.Unlock()\n```\n\nDo note that sometimes empty critical sections can be useful, as a form of signaling to wait on another goroutine. Many times, there are simpler ways of achieving the same effect. When that isn't the case, the code should be amply commented to avoid confusion. Combining such comments with a `//lint:ignore` directive can be used to suppress this rare false positive.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA2001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA2003","shortDescription":{"text":"Deferred Lock right after locking, likely meant to defer Unlock instead","markdown":"Deferred `Lock` right after locking, likely meant to defer `Unlock` instead"},"help":{"text":"Deferred Lock right after locking, likely meant to defer Unlock instead\n\n\n","markdown":"Deferred `Lock` right after locking, likely meant to defer `Unlock` instead\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA2003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4027","shortDescription":{"text":"(*net/url.URL).Query returns a copy, modifying it doesn't change the URL","markdown":"`(*net/url.URL).Query` returns a copy, modifying it doesn't change the URL"},"help":{"text":"(*net/url.URL).Query returns a copy, modifying it doesn't change the URL\n\n(*net/url.URL).Query parses the current value of net/url.URL.RawQuery and returns it as a map of type net/url.Values. Subsequent changes to this map will not affect the URL unless the map gets encoded and assigned to the URL's RawQuery.\n\nAs a consequence, the following code pattern is an expensive no-op: u.Query().Add(key, value).\n\n\n","markdown":"`(*net/url.URL).Query` returns a copy, modifying it doesn't change the URL\n\n`(*net/url.URL).Query` parses the current value of `net/url.URL.RawQuery` and returns it as a map of type `net/url.Values`. Subsequent changes to this map will not affect the URL unless the map gets encoded and assigned to the URL's `RawQuery`.\n\nAs a consequence, the following code pattern is an expensive no-op: `u.Query().Add(key, value)`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4027","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA6005","shortDescription":{"text":"Inefficient string comparison with strings.ToLower or strings.ToUpper","markdown":"Inefficient string comparison with `strings.ToLower` or `strings.ToUpper`"},"help":{"text":"Inefficient string comparison with strings.ToLower or strings.ToUpper\n\nConverting two strings to the same case and comparing them like so\n\n```go\nif strings.ToLower(s1) == strings.ToLower(s2) {\n    ...\n}\n```\n\nis significantly more expensive than comparing them with strings.EqualFold(s1, s2). This is due to memory usage as well as computational complexity.\n\nstrings.ToLower will have to allocate memory for the new strings, as well as convert both strings fully, even if they differ on the very first byte. strings.EqualFold, on the other hand, compares the strings one character at a time. It doesn't need to create two intermediate strings and can return as soon as the first non-matching character has been found.\n\nFor a more in-depth explanation of this issue, see https://blog.digitalocean.com/how-to-efficiently-compare-strings-in-go/\n\n\n","markdown":"Inefficient string comparison with `strings.ToLower` or `strings.ToUpper`\n\nConverting two strings to the same case and comparing them like so\n\n```go\nif strings.ToLower(s1) == strings.ToLower(s2) {\n    ...\n}\n```\n\nis significantly more expensive than comparing them with `strings.EqualFold(s1, s2)`. This is due to memory usage as well as computational complexity.\n\n`strings.ToLower` will have to allocate memory for the new strings, as well as convert both strings fully, even if they differ on the very first byte. strings.EqualFold, on the other hand, compares the strings one character at a time. It doesn't need to create two intermediate strings and can return as soon as the first non-matching character has been found.\n\nFor a more in-depth explanation of this issue, see https://blog.digitalocean.com/how-to-efficiently-compare-strings-in-go/\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4012","shortDescription":{"text":"Comparing a value against NaN even though no value is equal to NaN","markdown":"Comparing a value against NaN even though no value is equal to NaN"},"help":{"text":"Comparing a value against NaN even though no value is equal to NaN\n\n\n","markdown":"Comparing a value against NaN even though no value is equal to NaN\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4012","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4014","shortDescription":{"text":"An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either","markdown":"An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either"},"help":{"text":"An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either\n\n\n","markdown":"An if/else if chain has repeated conditions and no side-effects; if the condition didn't match the first time, it won't match the second time, either\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4014","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4015","shortDescription":{"text":"Calling functions like math.Ceil on floats converted from integers doesn't do anything useful","markdown":"Calling functions like `math.Ceil` on floats converted from integers doesn't do anything useful"},"help":{"text":"Calling functions like math.Ceil on floats converted from integers doesn't do anything useful\n\n\n","markdown":"Calling functions like `math.Ceil` on floats converted from integers doesn't do anything useful\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4015","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4025","shortDescription":{"text":"Integer division of literals that results in zero","markdown":"Integer division of literals that results in zero"},"help":{"text":"Integer division of literals that results in zero\n\nWhen dividing two integer constants, the result will also be an integer. Thus, a division such as 2 / 3 results in 0. This is true for all of the following examples:\n\n\t_ = 2 / 3 \tconst _ = 2 / 3 \tconst _ float64 = 2 / 3 \t_ = float64(2 / 3)\n\nStaticcheck will flag such divisions if both sides of the division are integer literals, as it is highly unlikely that the division was intended to truncate to zero. Staticcheck will not flag integer division involving named constants, to avoid noisy positives.\n\n\n","markdown":"Integer division of literals that results in zero\n\nWhen dividing two integer constants, the result will also be an integer. Thus, a division such as `2 / 3` results in `0`. This is true for all of the following examples:\n\n\t_ = 2 / 3 \tconst _ = 2 / 3 \tconst _ float64 = 2 / 3 \t_ = float64(2 / 3)\n\nStaticcheck will flag such divisions if both sides of the division are integer literals, as it is highly unlikely that the division was intended to truncate to zero. Staticcheck will not flag integer division involving named constants, to avoid noisy positives.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4025","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1016","shortDescription":{"text":"Trapping a signal that cannot be trapped","markdown":"Trapping a signal that cannot be trapped"},"help":{"text":"Trapping a signal that cannot be trapped\n\nNot all signals can be intercepted by a process. Specifically, on UNIX-like systems, the syscall.SIGKILL and syscall.SIGSTOP signals are never passed to the process, but instead handled directly by the kernel. It is therefore pointless to try and handle these signals.\n\n\n","markdown":"Trapping a signal that cannot be trapped\n\nNot all signals can be intercepted by a process. Specifically, on UNIX-like systems, the `syscall.SIGKILL` and `syscall.SIGSTOP` signals are never passed to the process, but instead handled directly by the kernel. It is therefore pointless to try and handle these signals.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1016","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4008","shortDescription":{"text":"The variable in the loop condition never changes, are you incrementing the wrong variable?","markdown":"The variable in the loop condition never changes, are you incrementing the wrong variable?"},"help":{"text":"The variable in the loop condition never changes, are you incrementing the wrong variable?\n\nFor example:\n\n\tfor i := 0; i \u003c 10; j++ { ... }\n\nThis may also occur when a loop can only execute once because of unconditional control flow that terminates the loop. For example, when a loop body contains an unconditional break, return, or panic:\n\n\tfunc f() { \t\tpanic(\"oops\") \t} \tfunc g() { \t\tfor i := 0; i \u003c 10; i++ { \t\t\t// f unconditionally calls panic, which means \"i\" is \t\t\t// never incremented. \t\t\tf() \t\t} \t}\n\n\n","markdown":"The variable in the loop condition never changes, are you incrementing the wrong variable?\n\nFor example:\n\n\tfor i := 0; i \u003c 10; j++ { ... }\n\nThis may also occur when a loop can only execute once because of unconditional control flow that terminates the loop. For example, when a loop body contains an unconditional break, return, or panic:\n\n\tfunc f() { \t\tpanic(\"oops\") \t} \tfunc g() { \t\tfor i := 0; i \u003c 10; i++ { \t\t\t// f unconditionally calls panic, which means \"i\" is \t\t\t// never incremented. \t\t\tf() \t\t} \t}\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4024","shortDescription":{"text":"Checking for impossible return value from a builtin function","markdown":"Checking for impossible return value from a builtin function"},"help":{"text":"Checking for impossible return value from a builtin function\n\nReturn values of the len and cap builtins cannot be negative.\n\nSee https://golang.org/pkg/builtin/#len and https://golang.org/pkg/builtin/#cap.\n\nExample:\n\n```go\nif len(slice) \u003c 0 {\n    fmt.Println(\"unreachable code\")\n}\n```\n\n\n","markdown":"Checking for impossible return value from a builtin function\n\nReturn values of the `len` and `cap` builtins cannot be negative.\n\nSee https://golang.org/pkg/builtin/#len and https://golang.org/pkg/builtin/#cap.\n\nExample:\n\n```go\nif len(slice) \u003c 0 {\n    fmt.Println(\"unreachable code\")\n}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4024","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5000","shortDescription":{"text":"Assignment to nil map","markdown":"Assignment to nil map"},"help":{"text":"Assignment to nil map\n\n\n","markdown":"Assignment to nil map\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5000","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA5004","shortDescription":{"text":"'for { select { ...' with an empty default branch spins","markdown":"`for { select { ...` with an empty default branch spins"},"help":{"text":"'for { select { ...' with an empty default branch spins\n\n\n","markdown":"`for { select { ...` with an empty default branch spins\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5004","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9006","shortDescription":{"text":"Dubious bit shifting of a fixed size integer value","markdown":"Dubious bit shifting of a fixed size integer value"},"help":{"text":"Dubious bit shifting of a fixed size integer value\n\nBit shifting a value past its size will always clear the value.\n\nFor instance:\n\n```go\nv := int8(42)\nv \u003e\u003e= 8\n```\n\nwill always result in 0.\n\nThis check flags bit shifting operations on fixed size integer values only. That is, int, uint and uintptr are never flagged to avoid potential false positives in somewhat exotic but valid bit twiddling tricks:\n\n```go\n// Clear any value above 32 bits if integers are more than 32 bits.\nfunc f(i int) int {\n    v := i \u003e\u003e 32\n    v = v \u003c\u003c 32\n    return i-v\n}\n```\n\n\n","markdown":"Dubious bit shifting of a fixed size integer value\n\nBit shifting a value past its size will always clear the value.\n\nFor instance:\n\n```go\nv := int8(42)\nv \u003e\u003e= 8\n```\n\nwill always result in 0.\n\nThis check flags bit shifting operations on fixed size integer values only. That is, int, uint and uintptr are never flagged to avoid potential false positives in somewhat exotic but valid bit twiddling tricks:\n\n```go\n// Clear any value above 32 bits if integers are more than 32 bits.\nfunc f(i int) int {\n    v := i \u003e\u003e 32\n    v = v \u003c\u003c 32\n    return i-v\n}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1003","shortDescription":{"text":"Replace call to strings.Index with strings.Contains","markdown":"Replace call to `strings.Index` with `strings.Contains`"},"help":{"text":"Replace call to strings.Index with strings.Contains\n\nBefore:\n\n```go\nif strings.Index(x, y) != -1 {}\n```\n\nAfter:\n\n```go\nif strings.Contains(x, y) {}\n```\n\n\n","markdown":"Replace call to `strings.Index` with `strings.Contains`\n\nBefore:\n\n```go\nif strings.Index(x, y) != -1 {}\n```\n\nAfter:\n\n```go\nif strings.Contains(x, y) {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1001","shortDescription":{"text":"Invalid template","markdown":"Invalid template"},"help":{"text":"Invalid template\n\n\n","markdown":"Invalid template\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1001","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA5010","shortDescription":{"text":"Impossible type assertion","markdown":"Impossible type assertion"},"help":{"text":"Impossible type assertion\n\nSome type assertions can be statically proven to be impossible. This is the case when the method sets of both arguments of the type assertion conflict with each other, for example by containing the same method with different signatures.\n\nThe Go compiler already applies this check when asserting from an interface value to a concrete type. If the concrete type misses methods from the interface, or if function signatures don't match, then the type assertion can never succeed.\n\nThis check applies the same logic when asserting from one interface to another. If both interface types contain the same method but with different signatures, then the type assertion can never succeed, either.\n\n\n","markdown":"Impossible type assertion\n\nSome type assertions can be statically proven to be impossible. This is the case when the method sets of both arguments of the type assertion conflict with each other, for example by containing the same method with different signatures.\n\nThe Go compiler already applies this check when asserting from an interface value to a concrete type. If the concrete type misses methods from the interface, or if function signatures don't match, then the type assertion can never succeed.\n\nThis check applies the same logic when asserting from one interface to another. If both interface types contain the same method but with different signatures, then the type assertion can never succeed, either.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5010","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9003","shortDescription":{"text":"Empty body in an if or else branch","markdown":"Empty body in an if or else branch"},"help":{"text":"Empty body in an if or else branch\n\n\n","markdown":"Empty body in an if or else branch\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1001","shortDescription":{"text":"Dot imports are discouraged","markdown":"Dot imports are discouraged"},"help":{"text":"Dot imports are discouraged\n\nDot imports that aren't in external test packages are discouraged.\n\nThe dot_import_whitelist option can be used to whitelist certain imports.\n\nQuoting Go Code Review Comments:\n\n\u003e The import . form can be useful in tests that, due to circular\n\u003e dependencies, cannot be made part of the package being tested:\n\u003e \n\u003e     package foo_test\n\u003e \n\u003e     import (\n\u003e         \"bar/testutil\" // also imports \"foo\"\n\u003e         . \"foo\"\n\u003e     )\n\u003e \n\u003e In this case, the test file cannot be in package foo because it\n\u003e uses bar/testutil, which imports foo. So we use the import .\n\u003e form to let the file pretend to be part of package foo even though\n\u003e it is not. Except for this one case, do not use import . in your\n\u003e programs. It makes the programs much harder to read because it is\n\u003e unclear whether a name like Quux is a top-level identifier in the\n\u003e current package or in an imported package.\n\n\n","markdown":"Dot imports are discouraged\n\nDot imports that aren't in external test packages are discouraged.\n\nThe `dot_import_whitelist` option can be used to whitelist certain imports.\n\nQuoting Go Code Review Comments:\n\n\u003e The `import .` form can be useful in tests that, due to circular\n\u003e dependencies, cannot be made part of the package being tested:\n\u003e \n\u003e     package foo_test\n\u003e \n\u003e     import (\n\u003e         \"bar/testutil\" // also imports \"foo\"\n\u003e         . \"foo\"\n\u003e     )\n\u003e \n\u003e In this case, the test file cannot be in package foo because it\n\u003e uses `bar/testutil`, which imports `foo`. So we use the `import .`\n\u003e form to let the file pretend to be part of package foo even though\n\u003e it is not. Except for this one case, do not use `import .` in your\n\u003e programs. It makes the programs much harder to read because it is\n\u003e unclear whether a name like `Quux` is a top-level identifier in the\n\u003e current package or in an imported package.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1016","shortDescription":{"text":"Use consistent method receiver names","markdown":"Use consistent method receiver names"},"help":{"text":"Use consistent method receiver names\n\n\n","markdown":"Use consistent method receiver names\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1016","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1032","shortDescription":{"text":"Wrong order of arguments to errors.Is","markdown":"Wrong order of arguments to `errors.Is`"},"help":{"text":"Wrong order of arguments to errors.Is\n\nThe first argument of the function errors.Is is the error that we have and the second argument is the error we're trying to match against. For example:\n\n\tif errors.Is(err, io.EOF) { ... }\n\nThis check detects some cases where the two arguments have been swapped. It flags any calls where the first argument is referring to a package-level error variable, such as\n\n\tif errors.Is(io.EOF, err) { /* this is wrong */ }\n\n\n","markdown":"Wrong order of arguments to `errors.Is`\n\nThe first argument of the function `errors.Is` is the error that we have and the second argument is the error we're trying to match against. For example:\n\n\tif errors.Is(err, io.EOF) { ... }\n\nThis check detects some cases where the two arguments have been swapped. It flags any calls where the first argument is referring to a package-level error variable, such as\n\n\tif errors.Is(io.EOF, err) { /* this is wrong */ }\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1032","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA3001","shortDescription":{"text":"Assigning to b.N in benchmarks distorts the results","markdown":"Assigning to `b.N` in benchmarks distorts the results"},"help":{"text":"Assigning to b.N in benchmarks distorts the results\n\nThe testing package dynamically sets b.N to improve the reliability of benchmarks and uses it in computations to determine the duration of a single operation. Benchmark code must not alter b.N as this would falsify results.\n\n\n","markdown":"Assigning to `b.N` in benchmarks distorts the results\n\nThe testing package dynamically sets `b.N` to improve the reliability of benchmarks and uses it in computations to determine the duration of a single operation. Benchmark code must not alter `b.N` as this would falsify results.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA3001","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA9009","shortDescription":{"text":"Ineffectual Go compiler directive","markdown":"Ineffectual Go compiler directive"},"help":{"text":"Ineffectual Go compiler directive\n\nA potential Go compiler directive was found, but is ineffectual as it begins with whitespace.\n\n\n","markdown":"Ineffectual Go compiler directive\n\nA potential Go compiler directive was found, but is ineffectual as it begins with whitespace.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9009","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1025","shortDescription":{"text":"It is not possible to use (*time.Timer).Reset's return value correctly","markdown":"It is not possible to use `(*time.Timer).Reset`'s return value correctly"},"help":{"text":"It is not possible to use (*time.Timer).Reset's return value correctly\n\n\n","markdown":"It is not possible to use `(*time.Timer).Reset`'s return value correctly\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1025","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5007","shortDescription":{"text":"Infinite recursive call","markdown":"Infinite recursive call"},"help":{"text":"Infinite recursive call\n\nA function that calls itself recursively needs to have an exit condition. Otherwise it will recurse forever, until the system runs out of memory.\n\nThis issue can be caused by simple bugs such as forgetting to add an exit condition. It can also happen \"on purpose\". Some languages have tail call optimization which makes certain infinite recursive calls safe to use. Go, however, does not implement TCO, and as such a loop should be used instead.\n\n\n","markdown":"Infinite recursive call\n\nA function that calls itself recursively needs to have an exit condition. Otherwise it will recurse forever, until the system runs out of memory.\n\nThis issue can be caused by simple bugs such as forgetting to add an exit condition. It can also happen \"on purpose\". Some languages have tail call optimization which makes certain infinite recursive calls safe to use. Go, however, does not implement TCO, and as such a loop should be used instead.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5007","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1012","shortDescription":{"text":"Poorly chosen name for error variable","markdown":"Poorly chosen name for error variable"},"help":{"text":"Poorly chosen name for error variable\n\nError variables that are part of an API should be called errFoo or ErrFoo.\n\n\n","markdown":"Poorly chosen name for error variable\n\nError variables that are part of an API should be called `errFoo` or `ErrFoo`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1012","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1012","shortDescription":{"text":"Replace time.Now().Sub(x) with time.Since(x)","markdown":"Replace `time.Now().Sub(x)` with `time.Since(x)`"},"help":{"text":"Replace time.Now().Sub(x) with time.Since(x)\n\nThe time.Since helper has the same effect as using time.Now().Sub(x) but is easier to read.\n\nBefore:\n\n```go\ntime.Now().Sub(x)\n```\n\nAfter:\n\n```go\ntime.Since(x)\n```\n\n\n","markdown":"Replace `time.Now().Sub(x)` with `time.Since(x)`\n\nThe `time.Since` helper has the same effect as using `time.Now().Sub(x)` but is easier to read.\n\nBefore:\n\n```go\ntime.Now().Sub(x)\n```\n\nAfter:\n\n```go\ntime.Since(x)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1012","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1027","shortDescription":{"text":"Atomic access to 64-bit variable must be 64-bit aligned","markdown":"Atomic access to 64-bit variable must be 64-bit aligned"},"help":{"text":"Atomic access to 64-bit variable must be 64-bit aligned\n\nOn ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.\n\nYou can use the structlayout tool to inspect the alignment of fields in a struct.\n\n\n","markdown":"Atomic access to 64-bit variable must be 64-bit aligned\n\nOn ARM, x86-32, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically. The first word in a variable or in an allocated struct, array, or slice can be relied upon to be 64-bit aligned.\n\nYou can use the structlayout tool to inspect the alignment of fields in a struct.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1027","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA2002","shortDescription":{"text":"Called testing.T.FailNow or SkipNow in a goroutine, which isn't allowed","markdown":"Called `testing.T.FailNow` or `SkipNow` in a goroutine, which isn't allowed"},"help":{"text":"Called testing.T.FailNow or SkipNow in a goroutine, which isn't allowed\n\n\n","markdown":"Called `testing.T.FailNow` or `SkipNow` in a goroutine, which isn't allowed\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA2002","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA4026","shortDescription":{"text":"Go constants cannot express negative zero","markdown":"Go constants cannot express negative zero"},"help":{"text":"Go constants cannot express negative zero\n\nIn IEEE 754 floating point math, zero has a sign and can be positive or negative. This can be useful in certain numerical code.\n\nGo constants, however, cannot express negative zero. This means that the literals -0.0 and 0.0 have the same ideal value (zero) and will both represent positive zero at runtime.\n\nTo explicitly and reliably create a negative zero, you can use the math.Copysign function: math.Copysign(0, -1).\n\n\n","markdown":"Go constants cannot express negative zero\n\nIn IEEE 754 floating point math, zero has a sign and can be positive or negative. This can be useful in certain numerical code.\n\nGo constants, however, cannot express negative zero. This means that the literals `-0.0` and `0.0` have the same ideal value (zero) and will both represent positive zero at runtime.\n\nTo explicitly and reliably create a negative zero, you can use the `math.Copysign` function: `math.Copysign(0, -1)`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4026","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4031","shortDescription":{"text":"Checking never-nil value against nil","markdown":"Checking never-nil value against nil"},"help":{"text":"Checking never-nil value against nil\n\n\n","markdown":"Checking never-nil value against nil\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4031","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1033","shortDescription":{"text":"Unnecessary guard around call to 'delete'","markdown":"Unnecessary guard around call to `delete`"},"help":{"text":"Unnecessary guard around call to 'delete'\n\nCalling delete on a nil map is a no-op.\n\n\n","markdown":"Unnecessary guard around call to `delete`\n\nCalling `delete` on a nil map is a no-op.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1033","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1005","shortDescription":{"text":"Invalid first argument to exec.Command","markdown":"Invalid first argument to `exec.Command`"},"help":{"text":"Invalid first argument to exec.Command\n\nos/exec runs programs directly (using variants of the fork and exec system calls on Unix systems). This shouldn't be confused with running a command in a shell. The shell will allow for features such as input redirection, pipes, and general scripting. The shell is also responsible for splitting the user's input into a program name and its arguments. For example, the equivalent to\n\n```go\nls / /tmp\n```\n\nwould be\n\n```go\nexec.Command(\"ls\", \"/\", \"/tmp\")\n```\n\nIf you want to run a command in a shell, consider using something like the following – but be aware that not all systems, particularly Windows, will have a /bin/sh program:\n\n```go\nexec.Command(\"/bin/sh\", \"-c\", \"ls | grep Awesome\")\n```\n\n\n","markdown":"Invalid first argument to `exec.Command`\n\n`os/exec` runs programs directly (using variants of the fork and exec system calls on Unix systems). This shouldn't be confused with running a command in a shell. The shell will allow for features such as input redirection, pipes, and general scripting. The shell is also responsible for splitting the user's input into a program name and its arguments. For example, the equivalent to\n\n```go\nls / /tmp\n```\n\nwould be\n\n```go\nexec.Command(\"ls\", \"/\", \"/tmp\")\n```\n\nIf you want to run a command in a shell, consider using something like the following – but be aware that not all systems, particularly Windows, will have a `/bin/sh` program:\n\n```go\nexec.Command(\"/bin/sh\", \"-c\", \"ls | grep Awesome\")\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1023","shortDescription":{"text":"Modifying the buffer in an io.Writer implementation","markdown":"Modifying the buffer in an `io.Writer` implementation"},"help":{"text":"Modifying the buffer in an io.Writer implementation\n\nWrite must not modify the slice data, even temporarily.\n\n\n","markdown":"Modifying the buffer in an `io.Writer` implementation\n\n`Write` must not modify the slice data, even temporarily.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1023","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA1024","shortDescription":{"text":"A string cutset contains duplicate characters","markdown":"A string cutset contains duplicate characters"},"help":{"text":"A string cutset contains duplicate characters\n\nThe strings.TrimLeft and strings.TrimRight functions take cutsets, not prefixes. A cutset is treated as a set of characters to remove from a string. For example,\n\n```go\nstrings.TrimLeft(\"42133word\", \"1234\")\n```\n\nwill result in the string \"word\" – any characters that are 1, 2, 3 or 4 are cut from the left of the string.\n\nIn order to remove one string from another, use strings.TrimPrefix instead.\n\n\n","markdown":"A string cutset contains duplicate characters\n\nThe `strings.TrimLeft` and `strings.TrimRight` functions take cutsets, not prefixes. A cutset is treated as a set of characters to remove from a string. For example,\n\n```go\nstrings.TrimLeft(\"42133word\", \"1234\")\n```\n\nwill result in the string `\"word\"` – any characters that are 1, 2, 3 or 4 are cut from the left of the string.\n\nIn order to remove one string from another, use `strings.TrimPrefix` instead.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1024","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4023","shortDescription":{"text":"Impossible comparison of interface value with untyped nil","markdown":"Impossible comparison of interface value with untyped nil"},"help":{"text":"Impossible comparison of interface value with untyped nil\n\nUnder the covers, interfaces are implemented as two elements, a type T and a value V. V is a concrete value such as an int, struct or pointer, never an interface itself, and has type T. For instance, if we store the int value 3 in an interface, the resulting interface value has, schematically, (T=int, V=3). The value V is also known as the interface's dynamic value, since a given interface variable might hold different values V (and corresponding types T) during the execution of the program.\n\nAn interface value is nil only if the V and T are both unset, (T=nil, V is not set), In particular, a nil interface will always hold a nil type. If we store a nil pointer of type *int inside an interface value, the inner type will be *int regardless of the value of the pointer: (T=*int, V=nil). Such an interface value will therefore be non-nil even when the pointer value V inside is nil.\n\nThis situation can be confusing, and arises when a nil value is stored inside an interface value such as an error return:\n\n```go\nfunc returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}\n```\n\nIf all goes well, the function returns a nil p, so the return value is an error interface value holding (T=*MyError, V=nil). This means that if the caller compares the returned error to nil, it will always look as if there was an error even if nothing bad happened. To return a proper nil error to the caller, the function must return an explicit nil:\n\n```go\nfunc returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}\n```\n\nIt's a good idea for functions that return errors always to use the error type in their signature (as we did above) rather than a concrete type such as *MyError, to help guarantee the error is created correctly. As an example, os.Open returns an error even though, if not nil, it's always of concrete type *os.PathError.\n\nSimilar situations to those described here can arise whenever interfaces are used. Just keep in mind that if any concrete value has been stored in the interface, the interface will not be nil. For more information, see The Laws of Reflection at https://golang.org/doc/articles/laws_of_reflection.html.\n\nThis text has been copied from https://golang.org/doc/faq#nil_error, licensed under the Creative Commons Attribution 3.0 License.\n\n\n","markdown":"Impossible comparison of interface value with untyped nil\n\nUnder the covers, interfaces are implemented as two elements, a type T and a value V. V is a concrete value such as an int, struct or pointer, never an interface itself, and has type T. For instance, if we store the int value 3 in an interface, the resulting interface value has, schematically, (T=int, V=3). The value V is also known as the interface's dynamic value, since a given interface variable might hold different values V (and corresponding types T) during the execution of the program.\n\nAn interface value is nil only if the V and T are both unset, (T=nil, V is not set), In particular, a nil interface will always hold a nil type. If we store a nil pointer of type *int inside an interface value, the inner type will be *int regardless of the value of the pointer: (T=*int, V=nil). Such an interface value will therefore be non-nil even when the pointer value V inside is nil.\n\nThis situation can be confusing, and arises when a nil value is stored inside an interface value such as an error return:\n\n```go\nfunc returnsError() error {\n    var p *MyError = nil\n    if bad() {\n        p = ErrBad\n    }\n    return p // Will always return a non-nil error.\n}\n```\n\nIf all goes well, the function returns a nil p, so the return value is an error interface value holding (T=*MyError, V=nil). This means that if the caller compares the returned error to nil, it will always look as if there was an error even if nothing bad happened. To return a proper nil error to the caller, the function must return an explicit nil:\n\n```go\nfunc returnsError() error {\n    if bad() {\n        return ErrBad\n    }\n    return nil\n}\n```\n\nIt's a good idea for functions that return errors always to use the error type in their signature (as we did above) rather than a concrete type such as `*MyError`, to help guarantee the error is created correctly. As an example, `os.Open` returns an error even though, if not nil, it's always of concrete type *os.PathError.\n\nSimilar situations to those described here can arise whenever interfaces are used. Just keep in mind that if any concrete value has been stored in the interface, the interface will not be nil. For more information, see The Laws of Reflection at https://golang.org/doc/articles/laws_of_reflection.html.\n\nThis text has been copied from https://golang.org/doc/faq#nil_error, licensed under the Creative Commons Attribution 3.0 License.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4023","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1008","shortDescription":{"text":"Simplify returning boolean expression","markdown":"Simplify returning boolean expression"},"help":{"text":"Simplify returning boolean expression\n\nBefore:\n\n```go\nif \u003cexpr\u003e {\n    return true\n}\nreturn false\n```\n\nAfter:\n\n```go\nreturn \u003cexpr\u003e\n```\n\n\n","markdown":"Simplify returning boolean expression\n\nBefore:\n\n```go\nif \u003cexpr\u003e {\n    return true\n}\nreturn false\n```\n\nAfter:\n\n```go\nreturn \u003cexpr\u003e\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1012","shortDescription":{"text":"A nil context.Context is being passed to a function, consider using context.TODO instead","markdown":"A nil `context.Context` is being passed to a function, consider using `context.TODO` instead"},"help":{"text":"A nil context.Context is being passed to a function, consider using context.TODO instead\n\n\n","markdown":"A nil `context.Context` is being passed to a function, consider using `context.TODO` instead\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1012","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4006","shortDescription":{"text":"A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?","markdown":"A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?"},"help":{"text":"A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?\n\n\n","markdown":"A value assigned to a variable is never read before being overwritten. Forgotten error check or dead code?\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4019","shortDescription":{"text":"Multiple, identical build constraints in the same file","markdown":"Multiple, identical build constraints in the same file"},"help":{"text":"Multiple, identical build constraints in the same file\n\n\n","markdown":"Multiple, identical build constraints in the same file\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4019","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA6003","shortDescription":{"text":"Converting a string to a slice of runes before ranging over it","markdown":"Converting a string to a slice of runes before ranging over it"},"help":{"text":"Converting a string to a slice of runes before ranging over it\n\nYou may want to loop over the runes in a string. Instead of converting the string to a slice of runes and looping over that, you can loop over the string itself. That is,\n\n```go\nfor _, r := range s {}\n```\n\nand\n\n```go\nfor _, r := range []rune(s) {}\n```\n\nwill yield the same values. The first version, however, will be faster and avoid unnecessary memory allocations.\n\nDo note that if you are interested in the indices, ranging over a string and over a slice of runes will yield different indices. The first one yields byte offsets, while the second one yields indices in the slice of runes.\n\n\n","markdown":"Converting a string to a slice of runes before ranging over it\n\nYou may want to loop over the runes in a string. Instead of converting the string to a slice of runes and looping over that, you can loop over the string itself. That is,\n\n```go\nfor _, r := range s {}\n```\n\nand\n\n```go\nfor _, r := range []rune(s) {}\n```\n\nwill yield the same values. The first version, however, will be faster and avoid unnecessary memory allocations.\n\nDo note that if you are interested in the indices, ranging over a string and over a slice of runes will yield different indices. The first one yields byte offsets, while the second one yields indices in the slice of runes.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1002","shortDescription":{"text":"Invalid format in time.Parse","markdown":"Invalid format in `time.Parse`"},"help":{"text":"Invalid format in time.Parse\n\n\n","markdown":"Invalid format in `time.Parse`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1002","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA6001","shortDescription":{"text":"Missing an optimization opportunity when indexing maps by byte slices","markdown":"Missing an optimization opportunity when indexing maps by byte slices"},"help":{"text":"Missing an optimization opportunity when indexing maps by byte slices\n\nMap keys must be comparable, which precludes the use of byte slices. This usually leads to using string keys and converting byte slices to strings.\n\nNormally, a conversion of a byte slice to a string needs to copy the data and causes allocations. The compiler, however, recognizes m[string(b)] and uses the data of b directly, without copying it, because it knows that the data can't change during the map lookup. This leads to the counter-intuitive situation that\n\n```go\nk := string(b)\nprintln(m[k])\nprintln(m[k])\n```\n\nwill be less efficient than\n\n```go\nprintln(m[string(b)])\nprintln(m[string(b)])\n```\n\nbecause the first version needs to copy and allocate, while the second one does not.\n\nFor some history on this optimization, check out commit f5f5a8b6209f84961687d993b93ea0d397f5d5bf in the Go repository.\n\n\n","markdown":"Missing an optimization opportunity when indexing maps by byte slices\n\nMap keys must be comparable, which precludes the use of byte slices. This usually leads to using string keys and converting byte slices to strings.\n\nNormally, a conversion of a byte slice to a string needs to copy the data and causes allocations. The compiler, however, recognizes `m[string(b)]` and uses the data of `b` directly, without copying it, because it knows that the data can't change during the map lookup. This leads to the counter-intuitive situation that\n\n```go\nk := string(b)\nprintln(m[k])\nprintln(m[k])\n```\n\nwill be less efficient than\n\n```go\nprintln(m[string(b)])\nprintln(m[string(b)])\n```\n\nbecause the first version needs to copy and allocate, while the second one does not.\n\nFor some history on this optimization, check out commit f5f5a8b6209f84961687d993b93ea0d397f5d5bf in the Go repository.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1000","shortDescription":{"text":"Incorrect or missing package comment","markdown":"Incorrect or missing package comment"},"help":{"text":"Incorrect or missing package comment\n\nPackages must have a package comment that is formatted according to the guidelines laid out in https://go.dev/wiki/CodeReviewComments#package-comments.\n\n\n","markdown":"Incorrect or missing package comment\n\nPackages must have a package comment that is formatted according to the guidelines laid out in https://go.dev/wiki/CodeReviewComments#package-comments.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"U1000","shortDescription":{"text":"Unused code","markdown":"Unused code"},"help":{"text":"Unused code\n\n\n","markdown":"Unused code\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#U1000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1025","shortDescription":{"text":"Don't use fmt.Sprintf(\"%s\", x) unnecessarily","markdown":"Don't use `fmt.Sprintf(\"%s\", x)` unnecessarily"},"help":{"text":"Don't use fmt.Sprintf(\"%s\", x) unnecessarily\n\nIn many instances, there are easier and more efficient ways of getting a value's string representation. Whenever a value's underlying type is a string already, or the type has a String method, they should be used directly.\n\nGiven the following shared definitions\n\n```go\ntype T1 string\ntype T2 int\n\nfunc (T2) String() string { return \"Hello, world\" }\n\nvar x string\nvar y T1\nvar z T2\n```\n\nwe can simplify\n\n```go\nfmt.Sprintf(\"%s\", x)\nfmt.Sprintf(\"%s\", y)\nfmt.Sprintf(\"%s\", z)\n```\n\nto\n\n```go\nx\nstring(y)\nz.String()\n```\n\n\n","markdown":"Don't use `fmt.Sprintf(\"%s\", x)` unnecessarily\n\nIn many instances, there are easier and more efficient ways of getting a value's string representation. Whenever a value's underlying type is a string already, or the type has a String method, they should be used directly.\n\nGiven the following shared definitions\n\n```go\ntype T1 string\ntype T2 int\n\nfunc (T2) String() string { return \"Hello, world\" }\n\nvar x string\nvar y T1\nvar z T2\n```\n\nwe can simplify\n\n```go\nfmt.Sprintf(\"%s\", x)\nfmt.Sprintf(\"%s\", y)\nfmt.Sprintf(\"%s\", z)\n```\n\nto\n\n```go\nx\nstring(y)\nz.String()\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1025","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5011","shortDescription":{"text":"Possible nil pointer dereference","markdown":"Possible nil pointer dereference"},"help":{"text":"Possible nil pointer dereference\n\nA pointer is being dereferenced unconditionally, while also being checked against nil in another place. This suggests that the pointer may be nil and dereferencing it may panic. This is commonly a result of improperly ordered code or missing return statements. Consider the following examples:\n\n```go\nfunc fn(x *int) {\n    fmt.Println(*x)\n\n    // This nil check is equally important for the previous dereference\n    if x != nil {\n        foo(*x)\n    }\n}\n\nfunc TestFoo(t *testing.T) {\n    x := compute()\n    if x == nil {\n        t.Errorf(\"nil pointer received\")\n    }\n\n    // t.Errorf does not abort the test, so if x is nil, the next line will panic.\n    foo(*x)\n}\n```\n\nStaticcheck tries to deduce which functions abort control flow. For example, it is aware that a function will not continue execution after a call to panic or log.Fatal. However, sometimes this detection fails, in particular in the presence of conditionals. Consider the following example:\n\n```go\nfunc Log(msg string, level int) {\n    fmt.Println(msg)\n    if level == levelFatal {\n        os.Exit(1)\n    }\n}\n\nfunc Fatal(msg string) {\n    Log(msg, levelFatal)\n}\n\nfunc fn(x *int) {\n    if x == nil {\n        Fatal(\"unexpected nil pointer\")\n    }\n    fmt.Println(*x)\n}\n```\n\nStaticcheck will flag the dereference of x, even though it is perfectly safe. Staticcheck is not able to deduce that a call to Fatal will exit the program. For the time being, the easiest workaround is to modify the definition of Fatal like so:\n\n```go\nfunc Fatal(msg string) {\n    Log(msg, levelFatal)\n    panic(\"unreachable\")\n}\n```\n\nWe also hard-code functions from common logging packages such as logrus. Please file an issue if we're missing support for a popular package.\n\n\n","markdown":"Possible nil pointer dereference\n\nA pointer is being dereferenced unconditionally, while also being checked against nil in another place. This suggests that the pointer may be nil and dereferencing it may panic. This is commonly a result of improperly ordered code or missing return statements. Consider the following examples:\n\n```go\nfunc fn(x *int) {\n    fmt.Println(*x)\n\n    // This nil check is equally important for the previous dereference\n    if x != nil {\n        foo(*x)\n    }\n}\n\nfunc TestFoo(t *testing.T) {\n    x := compute()\n    if x == nil {\n        t.Errorf(\"nil pointer received\")\n    }\n\n    // t.Errorf does not abort the test, so if x is nil, the next line will panic.\n    foo(*x)\n}\n```\n\nStaticcheck tries to deduce which functions abort control flow. For example, it is aware that a function will not continue execution after a call to `panic` or `log.Fatal`. However, sometimes this detection fails, in particular in the presence of conditionals. Consider the following example:\n\n```go\nfunc Log(msg string, level int) {\n    fmt.Println(msg)\n    if level == levelFatal {\n        os.Exit(1)\n    }\n}\n\nfunc Fatal(msg string) {\n    Log(msg, levelFatal)\n}\n\nfunc fn(x *int) {\n    if x == nil {\n        Fatal(\"unexpected nil pointer\")\n    }\n    fmt.Println(*x)\n}\n```\n\nStaticcheck will flag the dereference of `x`, even though it is perfectly safe. Staticcheck is not able to deduce that a call to Fatal will exit the program. For the time being, the easiest workaround is to modify the definition of Fatal like so:\n\n```go\nfunc Fatal(msg string) {\n    Log(msg, levelFatal)\n    panic(\"unreachable\")\n}\n```\n\nWe also hard-code functions from common logging packages such as logrus. Please file an issue if we're missing support for a popular package.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5011","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1019","shortDescription":{"text":"Importing the same package multiple times","markdown":"Importing the same package multiple times"},"help":{"text":"Importing the same package multiple times\n\nGo allows importing the same package multiple times, as long as different import aliases are being used. That is, the following bit of code is valid:\n\n```go\nimport (\n    \"fmt\"\n    fumpt \"fmt\"\n    format \"fmt\"\n    _ \"fmt\"\n)\n```\n\nHowever, this is very rarely done on purpose. Usually, it is a sign of code that got refactored, accidentally adding duplicate import statements. It is also a rarely known feature, which may contribute to confusion.\n\nDo note that sometimes, this feature may be used intentionally (see for example https://github.com/golang/go/commit/3409ce39bfd7584523b7a8c150a310cea92d879d) – if you want to allow this pattern in your code base, you're advised to disable this check.\n\n\n","markdown":"Importing the same package multiple times\n\nGo allows importing the same package multiple times, as long as different import aliases are being used. That is, the following bit of code is valid:\n\n```go\nimport (\n    \"fmt\"\n    fumpt \"fmt\"\n    format \"fmt\"\n    _ \"fmt\"\n)\n```\n\nHowever, this is very rarely done on purpose. Usually, it is a sign of code that got refactored, accidentally adding duplicate import statements. It is also a rarely known feature, which may contribute to confusion.\n\nDo note that sometimes, this feature may be used intentionally (see for example https://github.com/golang/go/commit/3409ce39bfd7584523b7a8c150a310cea92d879d) – if you want to allow this pattern in your code base, you're advised to disable this check.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1019","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1023","shortDescription":{"text":"Redundant type in variable declaration","markdown":"Redundant type in variable declaration"},"help":{"text":"Redundant type in variable declaration\n\n\n","markdown":"Redundant type in variable declaration\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1023","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1024","shortDescription":{"text":"Replace x.Sub(time.Now()) with time.Until(x)","markdown":"Replace `x.Sub(time.Now())` with `time.Until(x)`"},"help":{"text":"Replace x.Sub(time.Now()) with time.Until(x)\n\nThe time.Until helper has the same effect as using x.Sub(time.Now()) but is easier to read.\n\nBefore:\n\n```go\nx.Sub(time.Now())\n```\n\nAfter:\n\n```go\ntime.Until(x)\n```\n\n\n","markdown":"Replace `x.Sub(time.Now())` with `time.Until(x)`\n\nThe `time.Until` helper has the same effect as using `x.Sub(time.Now())` but is easier to read.\n\nBefore:\n\n```go\nx.Sub(time.Now())\n```\n\nAfter:\n\n```go\ntime.Until(x)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1024","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1010","shortDescription":{"text":"(*regexp.Regexp).FindAll called with n == 0, which will always return zero results","markdown":"`(*regexp.Regexp).FindAll` called with `n == 0`, which will always return zero results"},"help":{"text":"(*regexp.Regexp).FindAll called with n == 0, which will always return zero results\n\nIf n \u003e= 0, the function returns at most n matches/submatches. To return all results, specify a negative number.\n\n\n","markdown":"`(*regexp.Regexp).FindAll` called with `n == 0`, which will always return zero results\n\nIf `n \u003e= 0`, the function returns at most `n` matches/submatches. To return all results, specify a negative number.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1010","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1014","shortDescription":{"text":"Non-pointer value passed to Unmarshal or Decode","markdown":"Non-pointer value passed to `Unmarshal` or `Decode`"},"help":{"text":"Non-pointer value passed to Unmarshal or Decode\n\n\n","markdown":"Non-pointer value passed to `Unmarshal` or `Decode`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1014","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA1018","shortDescription":{"text":"strings.Replace called with n == 0, which does nothing","markdown":"`strings.Replace` called with `n == 0`, which does nothing"},"help":{"text":"strings.Replace called with n == 0, which does nothing\n\nWith n == 0, zero instances will be replaced. To replace all instances, use a negative number, or use strings.ReplaceAll.\n\n\n","markdown":"`strings.Replace` called with `n == 0`, which does nothing\n\nWith `n == 0`, zero instances will be replaced. To replace all instances, use a negative number, or use `strings.ReplaceAll`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1018","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA2000","shortDescription":{"text":"sync.WaitGroup.Add called inside the goroutine, leading to a race condition","markdown":"`sync.WaitGroup.Add` called inside the goroutine, leading to a race condition"},"help":{"text":"sync.WaitGroup.Add called inside the goroutine, leading to a race condition\n\n\n","markdown":"`sync.WaitGroup.Add` called inside the goroutine, leading to a race condition\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA2000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA3000","shortDescription":{"text":"TestMain doesn't call os.Exit, hiding test failures","markdown":"`TestMain` doesn't call `os.Exit`, hiding test failures"},"help":{"text":"TestMain doesn't call os.Exit, hiding test failures\n\nTest executables (and in turn 'go test') exit with a non-zero status code if any tests failed. When specifying your own TestMain function, it is your responsibility to arrange for this, by calling os.Exit with the correct code. The correct code is returned by (*testing.M).Run, so the usual way of implementing TestMain is to end it with os.Exit(m.Run()).\n\n\n","markdown":"`TestMain` doesn't call `os.Exit`, hiding test failures\n\nTest executables (and in turn `go test`) exit with a non-zero status code if any tests failed. When specifying your own `TestMain` function, it is your responsibility to arrange for this, by calling `os.Exit` with the correct code. The correct code is returned by `(*testing.M).Run`, so the usual way of implementing `TestMain` is to end it with `os.Exit(m.Run())`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA3000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4005","shortDescription":{"text":"Field assignment that will never be observed. Did you mean to use a pointer receiver?","markdown":"Field assignment that will never be observed. Did you mean to use a pointer receiver?"},"help":{"text":"Field assignment that will never be observed. Did you mean to use a pointer receiver?\n\n\n","markdown":"Field assignment that will never be observed. Did you mean to use a pointer receiver?\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1015","shortDescription":{"text":"Using time.Tick in a way that will leak. Consider using time.NewTicker, and only use time.Tick in tests, commands and endless functions","markdown":"Using `time.Tick` in a way that will leak. Consider using `time.NewTicker`, and only use `time.Tick` in tests, commands and endless functions"},"help":{"text":"Using time.Tick in a way that will leak. Consider using time.NewTicker, and only use time.Tick in tests, commands and endless functions\n\nBefore Go 1.23, time.Tickers had to be closed to be able to be garbage collected. Since time.Tick doesn't make it possible to close the underlying ticker, using it repeatedly would leak memory.\n\nGo 1.23 fixes this by allowing tickers to be collected even if they weren't closed.\n\n\n","markdown":"Using `time.Tick` in a way that will leak. Consider using `time.NewTicker`, and only use `time.Tick` in tests, commands and endless functions\n\nBefore Go 1.23, `time.Ticker`s had to be closed to be able to be garbage collected. Since `time.Tick` doesn't make it possible to close the underlying ticker, using it repeatedly would leak memory.\n\nGo 1.23 fixes this by allowing tickers to be collected even if they weren't closed.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1015","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4029","shortDescription":{"text":"Ineffective attempt at sorting slice","markdown":"Ineffective attempt at sorting slice"},"help":{"text":"Ineffective attempt at sorting slice\n\nsort.Float64Slice, sort.IntSlice, and sort.StringSlice are types, not functions. Doing x = sort.StringSlice(x) does nothing, especially not sort any values. The correct usage is sort.Sort(sort.StringSlice(x)) or sort.StringSlice(x).Sort(), but there are more convenient helpers, namely sort.Float64s, sort.Ints, and sort.Strings.\n\n\n","markdown":"Ineffective attempt at sorting slice\n\n`sort.Float64Slice`, `sort.IntSlice`, and `sort.StringSlice` are types, not functions. Doing `x = sort.StringSlice(x)` does nothing, especially not sort any values. The correct usage is `sort.Sort(sort.StringSlice(x))` or `sort.StringSlice(x).Sort()`, but there are more convenient helpers, namely `sort.Float64s`, `sort.Ints`, and `sort.Strings`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4029","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5009","shortDescription":{"text":"Invalid Printf call","markdown":"Invalid Printf call"},"help":{"text":"Invalid Printf call\n\n\n","markdown":"Invalid Printf call\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5009","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"S1001","shortDescription":{"text":"Replace for loop with call to copy","markdown":"Replace for loop with call to copy"},"help":{"text":"Replace for loop with call to copy\n\nUse copy() for copying elements from one slice to another. For arrays of identical size, you can use simple assignment.\n\nBefore:\n\n```go\nfor i, x := range src {\n    dst[i] = x\n}\n```\n\nAfter:\n\n```go\ncopy(dst, src)\n```\n\n\n","markdown":"Replace for loop with call to copy\n\nUse `copy()` for copying elements from one slice to another. For arrays of identical size, you can use simple assignment.\n\nBefore:\n\n```go\nfor i, x := range src {\n    dst[i] = x\n}\n```\n\nAfter:\n\n```go\ncopy(dst, src)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1007","shortDescription":{"text":"Simplify regular expression by using raw string literal","markdown":"Simplify regular expression by using raw string literal"},"help":{"text":"Simplify regular expression by using raw string literal\n\nRaw string literals use backticks instead of quotation marks and do not support any escape sequences. This means that the backslash can be used freely, without the need of escaping.\n\nSince regular expressions have their own escape sequences, raw strings can improve their readability.\n\nBefore:\n\n```go\nregexp.Compile(\"\\\\A(\\\\w+) profile: total \\\\d+\\\\n\\\\z\")\n```\n\nAfter:\n\n```go\nregexp.Compile(`\\A(\\w+) profile: total \\d+\\n\\z`)\n```\n\n\n","markdown":"Simplify regular expression by using raw string literal\n\nRaw string literals use backticks instead of quotation marks and do not support any escape sequences. This means that the backslash can be used freely, without the need of escaping.\n\nSince regular expressions have their own escape sequences, raw strings can improve their readability.\n\nBefore:\n\n```go\nregexp.Compile(\"\\\\A(\\\\w+) profile: total \\\\d+\\\\n\\\\z\")\n```\n\nAfter:\n\n```go\nregexp.Compile(`\\A(\\w+) profile: total \\d+\\n\\z`)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1007","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1023","shortDescription":{"text":"Omit redundant control flow","markdown":"Omit redundant control flow"},"help":{"text":"Omit redundant control flow\n\nFunctions that have no return value do not need a return statement as the final statement of the function.\n\nSwitches in Go do not have automatic fallthrough, unlike languages like C. It is not necessary to have a break statement as the final statement in a case block.\n\n\n","markdown":"Omit redundant control flow\n\nFunctions that have no return value do not need a return statement as the final statement of the function.\n\nSwitches in Go do not have automatic fallthrough, unlike languages like C. It is not necessary to have a break statement as the final statement in a case block.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1023","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1038","shortDescription":{"text":"Unnecessarily complex way of printing formatted string","markdown":"Unnecessarily complex way of printing formatted string"},"help":{"text":"Unnecessarily complex way of printing formatted string\n\nInstead of using fmt.Print(fmt.Sprintf(...)), one can use fmt.Printf(...).\n\n\n","markdown":"Unnecessarily complex way of printing formatted string\n\nInstead of using `fmt.Print(fmt.Sprintf(...))`, one can use `fmt.Printf(...)`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1038","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1040","shortDescription":{"text":"Type assertion to current type","markdown":"Type assertion to current type"},"help":{"text":"Type assertion to current type\n\nThe type assertion x.(SomeInterface), when x already has type SomeInterface, can only fail if x is nil. Usually, this is left-over code from when x had a different type and you can safely delete the type assertion. If you want to check that x is not nil, consider being explicit and using an actual if x == nil comparison instead of relying on the type assertion panicking.\n\n\n","markdown":"Type assertion to current type\n\nThe type assertion `x.(SomeInterface)`, when `x` already has type `SomeInterface`, can only fail if `x` is nil. Usually, this is left-over code from when `x` had a different type and you can safely delete the type assertion. If you want to check that `x` is not nil, consider being explicit and using an actual `if x == nil` comparison instead of relying on the type assertion panicking.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1040","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1006","shortDescription":{"text":"Printf with dynamic first argument and no further arguments","markdown":"`Printf` with dynamic first argument and no further arguments"},"help":{"text":"Printf with dynamic first argument and no further arguments\n\nUsing fmt.Printf with a dynamic first argument can lead to unexpected output. The first argument is a format string, where certain character combinations have special meaning. If, for example, a user were to enter a string such as\n\n```go\nInterest rate: 5%\n```\n\nand you printed it with\n\n```go\nfmt.Printf(s)\n```\n\nit would lead to the following output:\n\n```go\nInterest rate: 5%!(NOVERB).\n```\n\nSimilarly, forming the first parameter via string concatenation with user input should be avoided for the same reason. When printing user input, either use a variant of fmt.Print, or use the %s Printf verb and pass the string as an argument.\n\n\n","markdown":"`Printf` with dynamic first argument and no further arguments\n\nUsing `fmt.Printf` with a dynamic first argument can lead to unexpected output. The first argument is a format string, where certain character combinations have special meaning. If, for example, a user were to enter a string such as\n\n```go\nInterest rate: 5%\n```\n\nand you printed it with\n\n```go\nfmt.Printf(s)\n```\n\nit would lead to the following output:\n\n```go\nInterest rate: 5%!(NOVERB).\n```\n\nSimilarly, forming the first parameter via string concatenation with user input should be avoided for the same reason. When printing user input, either use a variant of `fmt.Print`, or use the `%s` Printf verb and pass the string as an argument.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9005","shortDescription":{"text":"Trying to marshal a struct with no public fields nor custom marshaling","markdown":"Trying to marshal a struct with no public fields nor custom marshaling"},"help":{"text":"Trying to marshal a struct with no public fields nor custom marshaling\n\nThe encoding/json and encoding/xml packages only operate on exported fields in structs, not unexported ones. It is usually an error to try to (un)marshal structs that only consist of unexported fields.\n\nThis check will not flag calls involving types that define custom marshaling behavior, e.g. via MarshalJSON methods. It will also not flag empty structs.\n\n\n","markdown":"Trying to marshal a struct with no public fields nor custom marshaling\n\nThe `encoding/json` and `encoding/xml` packages only operate on exported fields in structs, not unexported ones. It is usually an error to try to (un)marshal structs that only consist of unexported fields.\n\nThis check will not flag calls involving types that define custom marshaling behavior, e.g. via `MarshalJSON` methods. It will also not flag empty structs.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1021","shortDescription":{"text":"Using bytes.Equal to compare two net.IP","markdown":"Using `bytes.Equal` to compare two `net.IP`"},"help":{"text":"Using bytes.Equal to compare two net.IP\n\nA net.IP stores an IPv4 or IPv6 address as a slice of bytes. The length of the slice for an IPv4 address, however, can be either 4 or 16 bytes long, using different ways of representing IPv4 addresses. In order to correctly compare two net.IPs, the net.IP.Equal method should be used, as it takes both representations into account.\n\n\n","markdown":"Using `bytes.Equal` to compare two `net.IP`\n\nA `net.IP` stores an IPv4 or IPv6 address as a slice of bytes. The length of the slice for an IPv4 address, however, can be either 4 or 16 bytes long, using different ways of representing IPv4 addresses. In order to correctly compare two `net.IP`s, the `net.IP.Equal` method should be used, as it takes both representations into account.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1021","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1000","shortDescription":{"text":"Use plain channel send or receive instead of single-case select","markdown":"Use plain channel send or receive instead of single-case select"},"help":{"text":"Use plain channel send or receive instead of single-case select\n\nSelect statements with a single case can be replaced with a simple send or receive.\n\nBefore:\n\n```go\nselect {\ncase x := \u003c-ch:\n    fmt.Println(x)\n}\n```\n\nAfter:\n\n```go\nx := \u003c-ch\nfmt.Println(x)\n```\n\n\n","markdown":"Use plain channel send or receive instead of single-case select\n\nSelect statements with a single case can be replaced with a simple send or receive.\n\nBefore:\n\n```go\nselect {\ncase x := \u003c-ch:\n    fmt.Println(x)\n}\n```\n\nAfter:\n\n```go\nx := \u003c-ch\nfmt.Println(x)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1006","shortDescription":{"text":"Use 'for { ... }' for infinite loops","markdown":"Use `for { ... }` for infinite loops"},"help":{"text":"Use 'for { ... }' for infinite loops\n\nFor infinite loops, using for { ... } is the most idiomatic choice.\n\n\n","markdown":"Use `for { ... }` for infinite loops\n\nFor infinite loops, using `for { ... }` is the most idiomatic choice.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1037","shortDescription":{"text":"Elaborate way of sleeping","markdown":"Elaborate way of sleeping"},"help":{"text":"Elaborate way of sleeping\n\nUsing a select statement with a single case receiving from the result of time.After is a very elaborate way of sleeping that can much simpler be expressed with a simple call to time.Sleep.\n\n\n","markdown":"Elaborate way of sleeping\n\nUsing a select statement with a single case receiving from the result of `time.After` is a very elaborate way of sleeping that can much simpler be expressed with a simple call to time.Sleep.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1037","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1000","shortDescription":{"text":"Invalid regular expression","markdown":"Invalid regular expression"},"help":{"text":"Invalid regular expression\n\n\n","markdown":"Invalid regular expression\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1000","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA9002","shortDescription":{"text":"Using a non-octal os.FileMode that looks like it was meant to be in octal.","markdown":"Using a non-octal `os.FileMode` that looks like it was meant to be in octal."},"help":{"text":"Using a non-octal os.FileMode that looks like it was meant to be in octal.\n\n\n","markdown":"Using a non-octal `os.FileMode` that looks like it was meant to be in octal.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9002","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9008","shortDescription":{"text":"else branch of a type assertion is probably not reading the right value","markdown":"`else` branch of a type assertion is probably not reading the right value"},"help":{"text":"else branch of a type assertion is probably not reading the right value\n\nWhen declaring variables as part of an if statement (like in 'if foo := ...; foo {'), the same variables will also be in the scope of the else branch. This means that in the following example\n\n```go\nif x, ok := x.(int); ok {\n    // ...\n} else {\n    fmt.Printf(\"unexpected type %T\", x)\n}\n```\n\nx in the else branch will refer to the x from x, ok :=; it will not refer to the x that is being type-asserted. The result of a failed type assertion is the zero value of the type that is being asserted to, so x in the else branch will always have the value 0 and the type int.\n\n\n","markdown":"`else` branch of a type assertion is probably not reading the right value\n\nWhen declaring variables as part of an `if` statement (like in `if foo := ...; foo {`), the same variables will also be in the scope of the `else` branch. This means that in the following example\n\n```go\nif x, ok := x.(int); ok {\n    // ...\n} else {\n    fmt.Printf(\"unexpected type %T\", x)\n}\n```\n\n`x` in the `else` branch will refer to the `x` from `x, ok :=`; it will not refer to the `x` that is being type-asserted. The result of a failed type assertion is the zero value of the type that is being asserted to, so `x` in the else branch will always have the value `0` and the type `int`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1009","shortDescription":{"text":"Omit redundant nil check on slices, maps, and channels","markdown":"Omit redundant nil check on slices, maps, and channels"},"help":{"text":"Omit redundant nil check on slices, maps, and channels\n\nThe len function is defined for all slices, maps, and channels, even nil ones, which have a length of zero. It is not necessary to check for nil before checking that their length is not zero.\n\nBefore:\n\n```go\nif x != nil \u0026\u0026 len(x) != 0 {}\n```\n\nAfter:\n\n```go\nif len(x) != 0 {}\n```\n\n\n","markdown":"Omit redundant nil check on slices, maps, and channels\n\nThe `len` function is defined for all slices, maps, and channels, even nil ones, which have a length of zero. It is not necessary to check for nil before checking that their length is not zero.\n\nBefore:\n\n```go\nif x != nil \u0026\u0026 len(x) != 0 {}\n```\n\nAfter:\n\n```go\nif len(x) != 0 {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1009","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1017","shortDescription":{"text":"Replace manual trimming with strings.TrimPrefix","markdown":"Replace manual trimming with `strings.TrimPrefix`"},"help":{"text":"Replace manual trimming with strings.TrimPrefix\n\nInstead of using strings.HasPrefix and manual slicing, use the strings.TrimPrefix function. If the string doesn't start with the prefix, the original string will be returned. Using strings.TrimPrefix reduces complexity, and avoids common bugs, such as off-by-one mistakes.\n\nBefore:\n\n```go\nif strings.HasPrefix(str, prefix) {\n    str = str[len(prefix):]\n}\n```\n\nAfter:\n\n```go\nstr = strings.TrimPrefix(str, prefix)\n```\n\n\n","markdown":"Replace manual trimming with `strings.TrimPrefix`\n\nInstead of using `strings.HasPrefix` and manual slicing, use the `strings.TrimPrefix` function. If the string doesn't start with the prefix, the original string will be returned. Using `strings.TrimPrefix` reduces complexity, and avoids common bugs, such as off-by-one mistakes.\n\nBefore:\n\n```go\nif strings.HasPrefix(str, prefix) {\n    str = str[len(prefix):]\n}\n```\n\nAfter:\n\n```go\nstr = strings.TrimPrefix(str, prefix)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1017","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1032","shortDescription":{"text":"Use sort.Ints(x), sort.Float64s(x), and sort.Strings(x)","markdown":"Use `sort.Ints(x)`, `sort.Float64s(x)`, and `sort.Strings(x)`"},"help":{"text":"Use sort.Ints(x), sort.Float64s(x), and sort.Strings(x)\n\nThe sort.Ints, sort.Float64s and sort.Strings functions are easier to read than sort.Sort(sort.IntSlice(x)), sort.Sort(sort.Float64Slice(x)) and sort.Sort(sort.StringSlice(x)).\n\nBefore:\n\n```go\nsort.Sort(sort.StringSlice(x))\n```\n\nAfter:\n\n```go\nsort.Strings(x)\n```\n\n\n","markdown":"Use `sort.Ints(x)`, `sort.Float64s(x)`, and `sort.Strings(x)`\n\nThe `sort.Ints`, `sort.Float64s` and `sort.Strings` functions are easier to read than `sort.Sort(sort.IntSlice(x))`, `sort.Sort(sort.Float64Slice(x))` and `sort.Sort(sort.StringSlice(x))`.\n\nBefore:\n\n```go\nsort.Sort(sort.StringSlice(x))\n```\n\nAfter:\n\n```go\nsort.Strings(x)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1032","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4018","shortDescription":{"text":"Self-assignment of variables","markdown":"Self-assignment of variables"},"help":{"text":"Self-assignment of variables\n\n\n","markdown":"Self-assignment of variables\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4018","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4030","shortDescription":{"text":"Ineffective attempt at generating random number","markdown":"Ineffective attempt at generating random number"},"help":{"text":"Ineffective attempt at generating random number\n\nFunctions in the math/rand package that accept upper limits, such as Intn, generate random numbers in the half-open interval [0,n). In other words, the generated numbers will be \u003e= 0 and \u003c n – they don't include n. rand.Intn(1) therefore doesn't generate 0 or 1, it always generates 0.\n\n\n","markdown":"Ineffective attempt at generating random number\n\nFunctions in the `math/rand` package that accept upper limits, such as `Intn`, generate random numbers in the half-open interval [0,n). In other words, the generated numbers will be `\u003e= 0` and `\u003c n` – they don't include `n`. `rand.Intn(1)` therefore doesn't generate `0` or `1`, it always generates `0`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4030","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1034","shortDescription":{"text":"Use result of type assertion to simplify cases","markdown":"Use result of type assertion to simplify cases"},"help":{"text":"Use result of type assertion to simplify cases\n\n\n","markdown":"Use result of type assertion to simplify cases\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1034","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1007","shortDescription":{"text":"Invalid URL in net/url.Parse","markdown":"Invalid URL in `net/url.Parse`"},"help":{"text":"Invalid URL in net/url.Parse\n\n\n","markdown":"Invalid URL in `net/url.Parse`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1007","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA4000","shortDescription":{"text":"Binary operator has identical expressions on both sides","markdown":"Binary operator has identical expressions on both sides"},"help":{"text":"Binary operator has identical expressions on both sides\n\n\n","markdown":"Binary operator has identical expressions on both sides\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1018","shortDescription":{"text":"Avoid zero-width and control characters in string literals","markdown":"Avoid zero-width and control characters in string literals"},"help":{"text":"Avoid zero-width and control characters in string literals\n\n\n","markdown":"Avoid zero-width and control characters in string literals\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1018","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1021","shortDescription":{"text":"Merge variable declaration and assignment","markdown":"Merge variable declaration and assignment"},"help":{"text":"Merge variable declaration and assignment\n\nBefore:\n\n```go\nvar x uint\nx = 1\n```\n\nAfter:\n\n```go\nvar x uint = 1\n```\n\n\n","markdown":"Merge variable declaration and assignment\n\nBefore:\n\n```go\nvar x uint\nx = 1\n```\n\nAfter:\n\n```go\nvar x uint = 1\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1021","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1029","shortDescription":{"text":"Range over the string directly","markdown":"Range over the string directly"},"help":{"text":"Range over the string directly\n\nRanging over a string will yield byte offsets and runes. If the offset isn't used, this is functionally equivalent to converting the string to a slice of runes and ranging over that. Ranging directly over the string will be more performant, however, as it avoids allocating a new slice, the size of which depends on the length of the string.\n\nBefore:\n\n```go\nfor _, r := range []rune(s) {}\n```\n\nAfter:\n\n```go\nfor _, r := range s {}\n```\n\n\n","markdown":"Range over the string directly\n\nRanging over a string will yield byte offsets and runes. If the offset isn't used, this is functionally equivalent to converting the string to a slice of runes and ranging over that. Ranging directly over the string will be more performant, however, as it avoids allocating a new slice, the size of which depends on the length of the string.\n\nBefore:\n\n```go\nfor _, r := range []rune(s) {}\n```\n\nAfter:\n\n```go\nfor _, r := range s {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1029","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1004","shortDescription":{"text":"Suspiciously small untyped constant in time.Sleep","markdown":"Suspiciously small untyped constant in `time.Sleep`"},"help":{"text":"Suspiciously small untyped constant in time.Sleep\n\nThe time.Sleep function takes a time.Duration as its only argument. Durations are expressed in nanoseconds. Thus, calling time.Sleep(1) will sleep for 1 nanosecond. This is a common source of bugs, as sleep functions in other languages often accept seconds or milliseconds.\n\nThe time package provides constants such as time.Second to express large durations. These can be combined with arithmetic to express arbitrary durations, for example 5 * time.Second for 5 seconds.\n\nIf you truly meant to sleep for a tiny amount of time, use n * time.Nanosecond to signal to Staticcheck that you did mean to sleep for some amount of nanoseconds.\n\n\n","markdown":"Suspiciously small untyped constant in `time.Sleep`\n\nThe `time`.Sleep function takes a `time.Duration` as its only argument. Durations are expressed in nanoseconds. Thus, calling `time.Sleep(1)` will sleep for 1 nanosecond. This is a common source of bugs, as sleep functions in other languages often accept seconds or milliseconds.\n\nThe `time` package provides constants such as `time.Second` to express large durations. These can be combined with arithmetic to express arbitrary durations, for example `5 * time.Second` for 5 seconds.\n\nIf you truly meant to sleep for a tiny amount of time, use `n * time.Nanosecond` to signal to Staticcheck that you did mean to sleep for some amount of nanoseconds.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1004","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1008","shortDescription":{"text":"Non-canonical key in http.Header map","markdown":"Non-canonical key in `http.Header` map"},"help":{"text":"Non-canonical key in http.Header map\n\nKeys in http.Header maps are canonical, meaning they follow a specific combination of uppercase and lowercase letters. Methods such as http.Header.Add and http.Header.Del convert inputs into this canonical form before manipulating the map.\n\nWhen manipulating http.Header maps directly, as opposed to using the provided methods, care should be taken to stick to canonical form in order to avoid inconsistencies. The following piece of code demonstrates one such inconsistency:\n\n```go\nh := http.Header{}\nh[\"etag\"] = []string{\"1234\"}\nh.Add(\"etag\", \"5678\")\nfmt.Println(h)\n\n// Output:\n// map[Etag:[5678] etag:[1234]]\n```\n\nThe easiest way of obtaining the canonical form of a key is to use http.CanonicalHeaderKey.\n\n\n","markdown":"Non-canonical key in `http.Header` map\n\nKeys in `http.Header` maps are canonical, meaning they follow a specific combination of uppercase and lowercase letters. Methods such as `http.Header.Add` and `http.Header.Del` convert inputs into this canonical form before manipulating the map.\n\nWhen manipulating `http.Header` maps directly, as opposed to using the provided methods, care should be taken to stick to canonical form in order to avoid inconsistencies. The following piece of code demonstrates one such inconsistency:\n\n```go\nh := http.Header{}\nh[\"etag\"] = []string{\"1234\"}\nh.Add(\"etag\", \"5678\")\nfmt.Println(h)\n\n// Output:\n// map[Etag:[5678] etag:[1234]]\n```\n\nThe easiest way of obtaining the canonical form of a key is to use `http.CanonicalHeaderKey`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1017","shortDescription":{"text":"Channels used with os/signal.Notify should be buffered","markdown":"Channels used with `os/signal.Notify` should be buffered"},"help":{"text":"Channels used with os/signal.Notify should be buffered\n\nThe os/signal package uses non-blocking channel sends when delivering signals. If the receiving end of the channel isn't ready and the channel is either unbuffered or full, the signal will be dropped. To avoid missing signals, the channel should be buffered and of the appropriate size. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.\n\n\n","markdown":"Channels used with `os/signal.Notify` should be buffered\n\nThe `os/signal` package uses non-blocking channel sends when delivering signals. If the receiving end of the channel isn't ready and the channel is either unbuffered or full, the signal will be dropped. To avoid missing signals, the channel should be buffered and of the appropriate size. For a channel used for notification of just one signal value, a buffer of size 1 is sufficient.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1017","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4003","shortDescription":{"text":"Comparing unsigned values against negative values is pointless","markdown":"Comparing unsigned values against negative values is pointless"},"help":{"text":"Comparing unsigned values against negative values is pointless\n\n\n","markdown":"Comparing unsigned values against negative values is pointless\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1003","shortDescription":{"text":"Poorly chosen identifier","markdown":"Poorly chosen identifier"},"help":{"text":"Poorly chosen identifier\n\nIdentifiers, such as variable and package names, follow certain rules.\n\nSee the following links for details:\n\n- https://go.dev/doc/effective_go#package-names - https://go.dev/doc/effective_go#mixed-caps - https://go.dev/wiki/CodeReviewComments#initialisms - https://go.dev/wiki/CodeReviewComments#variable-names\n\n\n","markdown":"Poorly chosen identifier\n\nIdentifiers, such as variable and package names, follow certain rules.\n\nSee the following links for details:\n\n- https://go.dev/doc/effective_go#package-names - https://go.dev/doc/effective_go#mixed-caps - https://go.dev/wiki/CodeReviewComments#initialisms - https://go.dev/wiki/CodeReviewComments#variable-names\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1013","shortDescription":{"text":"Should use constants for HTTP error codes, not magic numbers","markdown":"Should use constants for HTTP error codes, not magic numbers"},"help":{"text":"Should use constants for HTTP error codes, not magic numbers\n\nHTTP has a tremendous number of status codes. While some of those are well known (200, 400, 404, 500), most of them are not. The net/http package provides constants for all status codes that are part of the various specifications. It is recommended to use these constants instead of hard-coding magic numbers, to vastly improve the readability of your code.\n\n\n","markdown":"Should use constants for HTTP error codes, not magic numbers\n\nHTTP has a tremendous number of status codes. While some of those are well known (200, 400, 404, 500), most of them are not. The `net/http` package provides constants for all status codes that are part of the various specifications. It is recommended to use these constants instead of hard-coding magic numbers, to vastly improve the readability of your code.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1013","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1028","shortDescription":{"text":"Simplify error construction with fmt.Errorf","markdown":"Simplify error construction with `fmt.Errorf`"},"help":{"text":"Simplify error construction with fmt.Errorf\n\nBefore:\n\n```go\nerrors.New(fmt.Sprintf(...))\n```\n\nAfter:\n\n```go\nfmt.Errorf(...)\n```\n\n\n","markdown":"Simplify error construction with `fmt.Errorf`\n\nBefore:\n\n```go\nerrors.New(fmt.Sprintf(...))\n```\n\nAfter:\n\n```go\nfmt.Errorf(...)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1028","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1036","shortDescription":{"text":"Unnecessary guard around map access","markdown":"Unnecessary guard around map access"},"help":{"text":"Unnecessary guard around map access\n\nWhen accessing a map key that doesn't exist yet, one receives a zero value. Often, the zero value is a suitable value, for example when using append or doing integer math.\n\nThe following\n\n```go\nif _, ok := m[\"foo\"]; ok {\n    m[\"foo\"] = append(m[\"foo\"], \"bar\")\n} else {\n    m[\"foo\"] = []string{\"bar\"}\n}\n```\n\ncan be simplified to\n\n```go\nm[\"foo\"] = append(m[\"foo\"], \"bar\")\n```\n\nand\n\n```go\nif _, ok := m2[\"k\"]; ok {\n    m2[\"k\"] += 4\n} else {\n    m2[\"k\"] = 4\n}\n```\n\ncan be simplified to\n\n```go\nm[\"k\"] += 4\n```\n\n\n","markdown":"Unnecessary guard around map access\n\nWhen accessing a map key that doesn't exist yet, one receives a zero value. Often, the zero value is a suitable value, for example when using append or doing integer math.\n\nThe following\n\n```go\nif _, ok := m[\"foo\"]; ok {\n    m[\"foo\"] = append(m[\"foo\"], \"bar\")\n} else {\n    m[\"foo\"] = []string{\"bar\"}\n}\n```\n\ncan be simplified to\n\n```go\nm[\"foo\"] = append(m[\"foo\"], \"bar\")\n```\n\nand\n\n```go\nif _, ok := m2[\"k\"]; ok {\n    m2[\"k\"] += 4\n} else {\n    m2[\"k\"] = 4\n}\n```\n\ncan be simplified to\n\n```go\nm[\"k\"] += 4\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1036","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1011","shortDescription":{"text":"Various methods in the 'strings' package expect valid UTF-8, but invalid input is provided","markdown":"Various methods in the `strings` package expect valid UTF-8, but invalid input is provided"},"help":{"text":"Various methods in the 'strings' package expect valid UTF-8, but invalid input is provided\n\n\n","markdown":"Various methods in the `strings` package expect valid UTF-8, but invalid input is provided\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1011","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA4028","shortDescription":{"text":"x % 1 is always zero","markdown":"`x % 1` is always zero"},"help":{"text":"x % 1 is always zero\n\n\n","markdown":"`x % 1` is always zero\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4028","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA6006","shortDescription":{"text":"Using io.WriteString to write []byte","markdown":"Using io.WriteString to write `[]byte`"},"help":{"text":"Using io.WriteString to write []byte\n\nUsing io.WriteString to write a slice of bytes, as in\n\n```go\nio.WriteString(w, string(b))\n```\n\nis both unnecessary and inefficient. Converting from []byte to string has to allocate and copy the data, and we could simply use w.Write(b) instead.\n\n\n","markdown":"Using io.WriteString to write `[]byte`\n\nUsing io.WriteString to write a slice of bytes, as in\n\n```go\nio.WriteString(w, string(b))\n```\n\nis both unnecessary and inefficient. Converting from `[]byte` to `string` has to allocate and copy the data, and we could simply use `w.Write(b)` instead.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6006","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9001","shortDescription":{"text":"Defers in range loops may not run when you expect them to","markdown":"Defers in range loops may not run when you expect them to"},"help":{"text":"Defers in range loops may not run when you expect them to\n\n\n","markdown":"Defers in range loops may not run when you expect them to\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA9007","shortDescription":{"text":"Deleting a directory that shouldn't be deleted","markdown":"Deleting a directory that shouldn't be deleted"},"help":{"text":"Deleting a directory that shouldn't be deleted\n\nIt is virtually never correct to delete system directories such as /tmp or the user's home directory. However, it can be fairly easy to do by mistake, for example by mistakenly using os.TempDir instead of ioutil.TempDir, or by forgetting to add a suffix to the result of os.UserHomeDir.\n\nWriting\n\n```go\nd := os.TempDir()\ndefer os.RemoveAll(d)\n```\n\nin your unit tests will have a devastating effect on the stability of your system.\n\nThis check flags attempts at deleting the following directories:\n\n- os.TempDir - os.UserCacheDir - os.UserConfigDir - os.UserHomeDir\n\n\n","markdown":"Deleting a directory that shouldn't be deleted\n\nIt is virtually never correct to delete system directories such as /tmp or the user's home directory. However, it can be fairly easy to do by mistake, for example by mistakenly using `os.TempDir` instead of `ioutil.TempDir`, or by forgetting to add a suffix to the result of `os.UserHomeDir`.\n\nWriting\n\n```go\nd := os.TempDir()\ndefer os.RemoveAll(d)\n```\n\nin your unit tests will have a devastating effect on the stability of your system.\n\nThis check flags attempts at deleting the following directories:\n\n- os.TempDir - os.UserCacheDir - os.UserConfigDir - os.UserHomeDir\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA9007","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1008","shortDescription":{"text":"A function's error value should be its last return value","markdown":"A function's error value should be its last return value"},"help":{"text":"A function's error value should be its last return value\n\nA function's error value should be its last return value.\n\n\n","markdown":"A function's error value should be its last return value\n\nA function's error value should be its last return value.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1020","shortDescription":{"text":"Omit redundant nil check in type assertion","markdown":"Omit redundant nil check in type assertion"},"help":{"text":"Omit redundant nil check in type assertion\n\nBefore:\n\n```go\nif _, ok := i.(T); ok \u0026\u0026 i != nil {}\n```\n\nAfter:\n\n```go\nif _, ok := i.(T); ok {}\n```\n\n\n","markdown":"Omit redundant nil check in type assertion\n\nBefore:\n\n```go\nif _, ok := i.(T); ok \u0026\u0026 i != nil {}\n```\n\nAfter:\n\n```go\nif _, ok := i.(T); ok {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1020","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1029","shortDescription":{"text":"Inappropriate key in call to context.WithValue","markdown":"Inappropriate key in call to `context.WithValue`"},"help":{"text":"Inappropriate key in call to context.WithValue\n\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys.\n\nTo avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables' static type should be a pointer or interface.\n\n\n","markdown":"Inappropriate key in call to `context.WithValue`\n\nThe provided key must be comparable and should not be of type `string` or any other built-in type to avoid collisions between packages using context. Users of `WithValue` should define their own types for keys.\n\nTo avoid allocating when assigning to an `interface{}`, context keys often have concrete type `struct{}`. Alternatively, exported context key variables' static type should be a pointer or interface.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1029","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4020","shortDescription":{"text":"Unreachable case clause in a type switch","markdown":"Unreachable case clause in a type switch"},"help":{"text":"Unreachable case clause in a type switch\n\nIn a type switch like the following\n\n```go\ntype T struct{}\nfunc (T) Read(b []byte) (int, error) { return 0, nil }\n\nvar v interface{} = T{}\n\nswitch v.(type) {\ncase io.Reader:\n    // ...\ncase T:\n    // unreachable\n}\n```\n\nthe second case clause can never be reached because T implements io.Reader and case clauses are evaluated in source order.\n\nAnother example:\n\n```go\ntype T struct{}\nfunc (T) Read(b []byte) (int, error) { return 0, nil }\nfunc (T) Close() error { return nil }\n\nvar v interface{} = T{}\n\nswitch v.(type) {\ncase io.Reader:\n    // ...\ncase io.ReadCloser:\n    // unreachable\n}\n```\n\nEven though T has a Close method and thus implements io.ReadCloser, io.Reader will always match first. The method set of io.Reader is a subset of io.ReadCloser. Thus it is impossible to match the second case without matching the first case.\n\n\n## Structurally equivalent interfaces\n\nA special case of the previous example are structurally identical interfaces. Given these declarations\n\n```go\ntype T error\ntype V error\n\nfunc doSomething() error {\n    err, ok := doAnotherThing()\n    if ok {\n        return T(err)\n    }\n\n    return U(err)\n}\n```\n\nthe following type switch will have an unreachable case clause:\n\n```go\nswitch doSomething().(type) {\ncase T:\n    // ...\ncase V:\n    // unreachable\n}\n```\n\nT will always match before V because they are structurally equivalent and therefore doSomething()'s return value implements both.\n\n\n","markdown":"Unreachable case clause in a type switch\n\nIn a type switch like the following\n\n```go\ntype T struct{}\nfunc (T) Read(b []byte) (int, error) { return 0, nil }\n\nvar v interface{} = T{}\n\nswitch v.(type) {\ncase io.Reader:\n    // ...\ncase T:\n    // unreachable\n}\n```\n\nthe second case clause can never be reached because `T` implements `io.Reader` and case clauses are evaluated in source order.\n\nAnother example:\n\n```go\ntype T struct{}\nfunc (T) Read(b []byte) (int, error) { return 0, nil }\nfunc (T) Close() error { return nil }\n\nvar v interface{} = T{}\n\nswitch v.(type) {\ncase io.Reader:\n    // ...\ncase io.ReadCloser:\n    // unreachable\n}\n```\n\nEven though `T` has a `Close` method and thus implements `io.ReadCloser`, `io.Reader` will always match first. The method set of `io.Reader` is a subset of `io.ReadCloser`. Thus it is impossible to match the second case without matching the first case.\n\n\n## Structurally equivalent interfaces\n\nA special case of the previous example are structurally identical interfaces. Given these declarations\n\n```go\ntype T error\ntype V error\n\nfunc doSomething() error {\n    err, ok := doAnotherThing()\n    if ok {\n        return T(err)\n    }\n\n    return U(err)\n}\n```\n\nthe following type switch will have an unreachable case clause:\n\n```go\nswitch doSomething().(type) {\ncase T:\n    // ...\ncase V:\n    // unreachable\n}\n```\n\n`T` will always match before V because they are structurally equivalent and therefore `doSomething()`'s return value implements both.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4020","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5001","shortDescription":{"text":"Deferring Close before checking for a possible error","markdown":"Deferring `Close` before checking for a possible error"},"help":{"text":"Deferring Close before checking for a possible error\n\n\n","markdown":"Deferring `Close` before checking for a possible error\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA6002","shortDescription":{"text":"Storing non-pointer values in sync.Pool allocates memory","markdown":"Storing non-pointer values in `sync.Pool` allocates memory"},"help":{"text":"Storing non-pointer values in sync.Pool allocates memory\n\nA sync.Pool is used to avoid unnecessary allocations and reduce the amount of work the garbage collector has to do.\n\nWhen passing a value that is not a pointer to a function that accepts an interface, the value needs to be placed on the heap, which means an additional allocation. Slices are a common thing to put in sync.Pools, and they're structs with 3 fields (length, capacity, and a pointer to an array). In order to avoid the extra allocation, one should store a pointer to the slice instead.\n\nSee the comments on https://go-review.googlesource.com/c/go/+/24371 that discuss this problem.\n\n\n","markdown":"Storing non-pointer values in `sync.Pool` allocates memory\n\nA `sync.Pool` is used to avoid unnecessary allocations and reduce the amount of work the garbage collector has to do.\n\nWhen passing a value that is not a pointer to a function that accepts an interface, the value needs to be placed on the heap, which means an additional allocation. Slices are a common thing to put in sync.Pools, and they're structs with 3 fields (length, capacity, and a pointer to an array). In order to avoid the extra allocation, one should store a pointer to the slice instead.\n\nSee the comments on https://go-review.googlesource.com/c/go/+/24371 that discuss this problem.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6002","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1005","shortDescription":{"text":"Incorrectly formatted error string","markdown":"Incorrectly formatted error string"},"help":{"text":"Incorrectly formatted error string\n\nError strings follow a set of guidelines to ensure uniformity and good composability.\n\nQuoting Go Code Review Comments:\n\n\u003e Error strings should not be capitalized (unless beginning with\n\u003e proper nouns or acronyms) or end with punctuation, since they are\n\u003e usually printed following other context. That is, use\n\u003e fmt.Errorf(\"something bad\") not fmt.Errorf(\"Something bad\"), so\n\u003e that log.Printf(\"Reading %s: %v\", filename, err) formats without a\n\u003e spurious capital letter mid-message.\n\n\n","markdown":"Incorrectly formatted error string\n\nError strings follow a set of guidelines to ensure uniformity and good composability.\n\nQuoting Go Code Review Comments:\n\n\u003e Error strings should not be capitalized (unless beginning with\n\u003e proper nouns or acronyms) or end with punctuation, since they are\n\u003e usually printed following other context. That is, use\n\u003e `fmt.Errorf(\"something bad\")` not `fmt.Errorf(\"Something bad\")`, so\n\u003e that `log.Printf(\"Reading %s: %v\", filename, err)` formats without a\n\u003e spurious capital letter mid-message.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1011","shortDescription":{"text":"Poorly chosen name for variable of type time.Duration","markdown":"Poorly chosen name for variable of type `time.Duration`"},"help":{"text":"Poorly chosen name for variable of type time.Duration\n\ntime.Duration values represent an amount of time, which is represented as a count of nanoseconds. An expression like 5 * time.Microsecond yields the value 5000. It is therefore not appropriate to suffix a variable of type time.Duration with any time unit, such as Msec or Milli.\n\n\n","markdown":"Poorly chosen name for variable of type `time.Duration`\n\n`time.Duration` values represent an amount of time, which is represented as a count of nanoseconds. An expression like `5 * time.Microsecond` yields the value `5000`. It is therefore not appropriate to suffix a variable of type `time.Duration` with any time unit, such as `Msec` or `Milli`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1011","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1020","shortDescription":{"text":"The documentation of an exported function should start with the function's name","markdown":"The documentation of an exported function should start with the function's name"},"help":{"text":"The documentation of an exported function should start with the function's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n","markdown":"The documentation of an exported function should start with the function's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the `doc` subcommand of the `go` tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1020","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1030","shortDescription":{"text":"Use bytes.Buffer.String or bytes.Buffer.Bytes","markdown":"Use `bytes.Buffer.String` or `bytes.Buffer.Bytes`"},"help":{"text":"Use bytes.Buffer.String or bytes.Buffer.Bytes\n\nbytes.Buffer has both a String and a Bytes method. It is almost never necessary to use string(buf.Bytes()) or []byte(buf.String()) – simply use the other method.\n\nThe only exception to this are map lookups. Due to a compiler optimization, m[string(buf.Bytes())] is more efficient than m[buf.String()].\n\n\n","markdown":"Use `bytes.Buffer.String` or `bytes.Buffer.Bytes`\n\n`bytes.Buffer` has both a `String` and a `Bytes` method. It is almost never necessary to use `string(buf.Bytes())` or `[]byte(buf.String())` – simply use the other method.\n\nThe only exception to this are map lookups. Due to a compiler optimization, `m[string(buf.Bytes())]` is more efficient than `m[buf.String()]`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1030","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4016","shortDescription":{"text":"Certain bitwise operations, such as x ^ 0, do not do anything useful","markdown":"Certain bitwise operations, such as `x ^ 0`, do not do anything useful"},"help":{"text":"Certain bitwise operations, such as x ^ 0, do not do anything useful\n\n\n","markdown":"Certain bitwise operations, such as `x ^ 0`, do not do anything useful\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4016","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5008","shortDescription":{"text":"Invalid struct tag","markdown":"Invalid struct tag"},"help":{"text":"Invalid struct tag\n\n\n","markdown":"Invalid struct tag\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5008","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA6000","shortDescription":{"text":"Using regexp.Match or related in a loop, should use regexp.Compile","markdown":"Using `regexp.Match` or related in a loop, should use `regexp.Compile`"},"help":{"text":"Using regexp.Match or related in a loop, should use regexp.Compile\n\n\n","markdown":"Using `regexp.Match` or related in a loop, should use `regexp.Compile`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA6000","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1005","shortDescription":{"text":"Drop unnecessary use of the blank identifier","markdown":"Drop unnecessary use of the blank identifier"},"help":{"text":"Drop unnecessary use of the blank identifier\n\nIn many cases, assigning to the blank identifier is unnecessary.\n\nBefore:\n\n```go\nfor _ = range s {}\nx, _ = someMap[key]\n_ = \u003c-ch\n```\n\nAfter:\n\n```go\nfor range s{}\nx = someMap[key]\n\u003c-ch\n```\n\n\n","markdown":"Drop unnecessary use of the blank identifier\n\nIn many cases, assigning to the blank identifier is unnecessary.\n\nBefore:\n\n```go\nfor _ = range s {}\nx, _ = someMap[key]\n_ = \u003c-ch\n```\n\nAfter:\n\n```go\nfor range s{}\nx = someMap[key]\n\u003c-ch\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1005","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1031","shortDescription":{"text":"Omit redundant nil check around loop","markdown":"Omit redundant nil check around loop"},"help":{"text":"Omit redundant nil check around loop\n\nYou can use range on nil slices and maps, the loop will simply never execute. This makes an additional nil check around the loop unnecessary.\n\nBefore:\n\n```go\nif s != nil {\n    for _, x := range s {\n        ...\n    }\n}\n```\n\nAfter:\n\n```go\nfor _, x := range s {\n    ...\n}\n```\n\n\n","markdown":"Omit redundant nil check around loop\n\nYou can use range on nil slices and maps, the loop will simply never execute. This makes an additional nil check around the loop unnecessary.\n\nBefore:\n\n```go\nif s != nil {\n    for _, x := range s {\n        ...\n    }\n}\n```\n\nAfter:\n\n```go\nfor _, x := range s {\n    ...\n}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1031","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1020","shortDescription":{"text":"Using an invalid host:port pair with a net.Listen-related function","markdown":"Using an invalid host:port pair with a `net.Listen`-related function"},"help":{"text":"Using an invalid host:port pair with a net.Listen-related function\n\n\n","markdown":"Using an invalid host:port pair with a `net.Listen`-related function\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1020","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA1026","shortDescription":{"text":"Cannot marshal channels or functions","markdown":"Cannot marshal channels or functions"},"help":{"text":"Cannot marshal channels or functions\n\n\n","markdown":"Cannot marshal channels or functions\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1026","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA4032","shortDescription":{"text":"Comparing runtime.GOOS or runtime.GOARCH against impossible value","markdown":"Comparing `runtime.GOOS` or `runtime.GOARCH` against impossible value"},"help":{"text":"Comparing runtime.GOOS or runtime.GOARCH against impossible value\n\n\n","markdown":"Comparing `runtime.GOOS` or `runtime.GOARCH` against impossible value\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4032","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5012","shortDescription":{"text":"Passing odd-sized slice to function expecting even size","markdown":"Passing odd-sized slice to function expecting even size"},"help":{"text":"Passing odd-sized slice to function expecting even size\n\nSome functions that take slices as parameters expect the slices to have an even number of elements.  Often, these functions treat elements in a slice as pairs.  For example, strings.NewReplacer takes pairs of old and new strings,  and calling it with an odd number of elements would be an error.\n\n\n","markdown":"Passing odd-sized slice to function expecting even size\n\nSome functions that take slices as parameters expect the slices to have an even number of elements.  Often, these functions treat elements in a slice as pairs.  For example, `strings.NewReplacer` takes pairs of old and new strings,  and calling it with an odd number of elements would be an error.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5012","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"ST1022","shortDescription":{"text":"The documentation of an exported variable or constant should start with variable's name","markdown":"The documentation of an exported variable or constant should start with variable's name"},"help":{"text":"The documentation of an exported variable or constant should start with variable's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n","markdown":"The documentation of an exported variable or constant should start with variable's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the `doc` subcommand of the `go` tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1022","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1028","shortDescription":{"text":"sort.Slice can only be used on slices","markdown":"`sort.Slice` can only be used on slices"},"help":{"text":"sort.Slice can only be used on slices\n\nThe first argument of sort.Slice must be a slice.\n\n\n","markdown":"`sort.Slice` can only be used on slices\n\nThe first argument of `sort.Slice` must be a slice.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1028","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"ST1015","shortDescription":{"text":"A switch's default case should be the first or last case","markdown":"A switch's default case should be the first or last case"},"help":{"text":"A switch's default case should be the first or last case\n\n\n","markdown":"A switch's default case should be the first or last case\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1015","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1016","shortDescription":{"text":"Use a type conversion instead of manually copying struct fields","markdown":"Use a type conversion instead of manually copying struct fields"},"help":{"text":"Use a type conversion instead of manually copying struct fields\n\nTwo struct types with identical fields can be converted between each other. In older versions of Go, the fields had to have identical struct tags. Since Go 1.8, however, struct tags are ignored during conversions. It is thus not necessary to manually copy every field individually.\n\nBefore:\n\n```go\nvar x T1\ny := T2{\n    Field1: x.Field1,\n    Field2: x.Field2,\n}\n```\n\nAfter:\n\n```go\nvar x T1\ny := T2(x)\n```\n\n\n","markdown":"Use a type conversion instead of manually copying struct fields\n\nTwo struct types with identical fields can be converted between each other. In older versions of Go, the fields had to have identical struct tags. Since Go 1.8, however, struct tags are ignored during conversions. It is thus not necessary to manually copy every field individually.\n\nBefore:\n\n```go\nvar x T1\ny := T2{\n    Field1: x.Field1,\n    Field2: x.Field2,\n}\n```\n\nAfter:\n\n```go\nvar x T1\ny := T2(x)\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1016","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1003","shortDescription":{"text":"Unsupported argument to functions in encoding/binary","markdown":"Unsupported argument to functions in `encoding/binary`"},"help":{"text":"Unsupported argument to functions in encoding/binary\n\nThe encoding/binary package can only serialize types with known sizes. This precludes the use of the int and uint types, as their sizes differ on different architectures. Furthermore, it doesn't support serializing maps, channels, strings, or functions.\n\nBefore Go 1.8, bool wasn't supported, either.\n\n\n","markdown":"Unsupported argument to functions in `encoding/binary`\n\nThe `encoding/binary` package can only serialize types with known sizes. This precludes the use of the `int` and `uint` types, as their sizes differ on different architectures. Furthermore, it doesn't support serializing maps, channels, strings, or functions.\n\nBefore Go 1.8, `bool` wasn't supported, either.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1003","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA1019","shortDescription":{"text":"Using a deprecated function, variable, constant or field","markdown":"Using a deprecated function, variable, constant or field"},"help":{"text":"Using a deprecated function, variable, constant or field\n\n\n","markdown":"Using a deprecated function, variable, constant or field\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1019","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4004","shortDescription":{"text":"The loop exits unconditionally after one iteration","markdown":"The loop exits unconditionally after one iteration"},"help":{"text":"The loop exits unconditionally after one iteration\n\n\n","markdown":"The loop exits unconditionally after one iteration\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4004","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4010","shortDescription":{"text":"The result of append will never be observed anywhere","markdown":"The result of `append` will never be observed anywhere"},"help":{"text":"The result of append will never be observed anywhere\n\n\n","markdown":"The result of `append` will never be observed anywhere\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4010","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4013","shortDescription":{"text":"Negating a boolean twice (!!b) is the same as writing b. This is either redundant, or a typo.","markdown":"Negating a boolean twice (`!!b`) is the same as writing `b`. This is either redundant, or a typo."},"help":{"text":"Negating a boolean twice (!!b) is the same as writing b. This is either redundant, or a typo.\n\n\n","markdown":"Negating a boolean twice (`!!b`) is the same as writing `b`. This is either redundant, or a typo.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4013","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4021","shortDescription":{"text":"'x = append(y)' is equivalent to 'x = y'","markdown":"`x = append(y)` is equivalent to `x = y`"},"help":{"text":"'x = append(y)' is equivalent to 'x = y'\n\n\n","markdown":"`x = append(y)` is equivalent to `x = y`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4021","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1021","shortDescription":{"text":"The documentation of an exported type should start with type's name","markdown":"The documentation of an exported type should start with type's name"},"help":{"text":"The documentation of an exported type should start with type's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the doc subcommand of the go tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n","markdown":"The documentation of an exported type should start with type's name\n\nDoc comments work best as complete sentences, which allow a wide variety of automated presentations. The first sentence should be a one-sentence summary that starts with the name being declared.\n\nIf every doc comment begins with the name of the item it describes, you can use the `doc` subcommand of the `go` tool and run the output through grep.\n\nSee https://go.dev/doc/effective_go#commentary for more information on how to write good documentation.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1021","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1002","shortDescription":{"text":"Omit comparison with boolean constant","markdown":"Omit comparison with boolean constant"},"help":{"text":"Omit comparison with boolean constant\n\nBefore:\n\n```go\nif x == true {}\n```\n\nAfter:\n\n```go\nif x {}\n```\n\n\n","markdown":"Omit comparison with boolean constant\n\nBefore:\n\n```go\nif x == true {}\n```\n\nAfter:\n\n```go\nif x {}\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1002","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1010","shortDescription":{"text":"Omit default slice index","markdown":"Omit default slice index"},"help":{"text":"Omit default slice index\n\nWhen slicing, the second index defaults to the length of the value, making s[n:len(s)] and s[n:] equivalent.\n\n\n","markdown":"Omit default slice index\n\nWhen slicing, the second index defaults to the length of the value, making `s[n:len(s)]` and `s[n:]` equivalent.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1010","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1018","shortDescription":{"text":"Use 'copy' for sliding elements","markdown":"Use `copy` for sliding elements"},"help":{"text":"Use 'copy' for sliding elements\n\ncopy() permits using the same source and destination slice, even with overlapping ranges. This makes it ideal for sliding elements in a slice.\n\nBefore:\n\n```go\nfor i := 0; i \u003c n; i++ {\n    bs[i] = bs[offset+i]\n}\n```\n\nAfter:\n\n```go\ncopy(bs[:n], bs[offset:])\n```\n\n\n","markdown":"Use `copy` for sliding elements\n\n`copy()` permits using the same source and destination slice, even with overlapping ranges. This makes it ideal for sliding elements in a slice.\n\nBefore:\n\n```go\nfor i := 0; i \u003c n; i++ {\n    bs[i] = bs[offset+i]\n}\n```\n\nAfter:\n\n```go\ncopy(bs[:n], bs[offset:])\n```\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1018","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1019","shortDescription":{"text":"Simplify 'make' call by omitting redundant arguments","markdown":"Simplify `make` call by omitting redundant arguments"},"help":{"text":"Simplify 'make' call by omitting redundant arguments\n\nThe 'make' function has default values for the length and capacity arguments. For channels, the length defaults to zero, and for slices, the capacity defaults to the length.\n\n\n","markdown":"Simplify `make` call by omitting redundant arguments\n\nThe `make` function has default values for the length and capacity arguments. For channels, the length defaults to zero, and for slices, the capacity defaults to the length.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1019","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"S1035","shortDescription":{"text":"Redundant call to net/http.CanonicalHeaderKey in method call on net/http.Header","markdown":"Redundant call to `net/http.CanonicalHeaderKey` in method call on `net/http.Header`"},"help":{"text":"Redundant call to net/http.CanonicalHeaderKey in method call on net/http.Header\n\nThe methods on net/http.Header, namely Add, Del, Get and Set, already canonicalize the given header name.\n\n\n","markdown":"Redundant call to `net/http.CanonicalHeaderKey` in method call on `net/http.Header`\n\nThe methods on `net/http.Header`, namely `Add`, `Del`, `Get` and `Set`, already canonicalize the given header name.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#S1035","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1030","shortDescription":{"text":"Invalid argument in call to a strconv function","markdown":"Invalid argument in call to a `strconv` function"},"help":{"text":"Invalid argument in call to a strconv function\n\nThis check validates the format, number base and bit size arguments of the various parsing and formatting functions in strconv.\n\n\n","markdown":"Invalid argument in call to a `strconv` function\n\nThis check validates the format, number base and bit size arguments of the various parsing and formatting functions in `strconv`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1030","defaultConfiguration":{"enabled":true,"level":"error"}},{"id":"SA1031","shortDescription":{"text":"Overlapping byte slices passed to an encoder","markdown":"Overlapping byte slices passed to an encoder"},"help":{"text":"Overlapping byte slices passed to an encoder\n\nIn an encoding function of the form Encode(dst, src), dst and src were found to reference the same memory. This can result in src bytes being overwritten before they are read, when the encoder writes more than one byte per src byte.\n\n\n","markdown":"Overlapping byte slices passed to an encoder\n\nIn an encoding function of the form `Encode(dst, src)`, `dst` and `src` were found to reference the same memory. This can result in `src` bytes being overwritten before they are read, when the encoder writes more than one byte per `src` byte.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1031","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4022","shortDescription":{"text":"Comparing the address of a variable against nil","markdown":"Comparing the address of a variable against nil"},"help":{"text":"Comparing the address of a variable against nil\n\nCode such as 'if \u0026x == nil' is meaningless, because taking the address of a variable always yields a non-nil pointer.\n\n\n","markdown":"Comparing the address of a variable against nil\n\nCode such as `if \u0026x == nil` is meaningless, because taking the address of a variable always yields a non-nil pointer.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4022","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA1013","shortDescription":{"text":"io.Seeker.Seek is being called with the whence constant as the first argument, but it should be the second","markdown":"`io.Seeker.Seek` is being called with the whence constant as the first argument, but it should be the second"},"help":{"text":"io.Seeker.Seek is being called with the whence constant as the first argument, but it should be the second\n\n\n","markdown":"`io.Seeker.Seek` is being called with the whence constant as the first argument, but it should be the second\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA1013","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4011","shortDescription":{"text":"Break statement with no effect. Did you mean to break out of an outer loop?","markdown":"Break statement with no effect. Did you mean to break out of an outer loop?"},"help":{"text":"Break statement with no effect. Did you mean to break out of an outer loop?\n\n\n","markdown":"Break statement with no effect. Did you mean to break out of an outer loop?\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4011","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4017","shortDescription":{"text":"Discarding the return values of a function without side effects, making the call pointless","markdown":"Discarding the return values of a function without side effects, making the call pointless"},"help":{"text":"Discarding the return values of a function without side effects, making the call pointless\n\n\n","markdown":"Discarding the return values of a function without side effects, making the call pointless\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4017","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA5003","shortDescription":{"text":"Defers in infinite loops will never execute","markdown":"Defers in infinite loops will never execute"},"help":{"text":"Defers in infinite loops will never execute\n\nDefers are scoped to the surrounding function, not the surrounding block. In a function that never returns, i.e. one containing an infinite loop, defers will never execute.\n\n\n","markdown":"Defers in infinite loops will never execute\n\nDefers are scoped to the surrounding function, not the surrounding block. In a function that never returns, i.e. one containing an infinite loop, defers will never execute.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA5003","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"SA4001","shortDescription":{"text":"\u0026*x gets simplified to x, it does not copy x","markdown":"`\u0026*x` gets simplified to `x`, it does not copy `x`"},"help":{"text":"\u0026*x gets simplified to x, it does not copy x\n\n\n","markdown":"`\u0026*x` gets simplified to `x`, it does not copy `x`\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#SA4001","defaultConfiguration":{"enabled":true,"level":"warning"}},{"id":"ST1017","shortDescription":{"text":"Don't use Yoda conditions","markdown":"Don't use Yoda conditions"},"help":{"text":"Don't use Yoda conditions\n\nYoda conditions are conditions of the kind 'if 42 == x', where the literal is on the left side of the comparison. These are a common idiom in languages in which assignment is an expression, to avoid bugs of the kind 'if (x = 42)'. In Go, which doesn't allow for this kind of bug, we prefer the more idiomatic 'if x == 42'.\n\n\n","markdown":"Don't use Yoda conditions\n\nYoda conditions are conditions of the kind `if 42 == x`, where the literal is on the left side of the comparison. These are a common idiom in languages in which assignment is an expression, to avoid bugs of the kind `if (x = 42)`. In Go, which doesn't allow for this kind of bug, we prefer the more idiomatic `if x == 42`.\n\n\n"},"helpUri":"https://staticcheck.dev/docs/checks#ST1017","defaultConfiguration":{"enabled":true,"level":"warning"}}]}},"results":[{"ruleId":"compile","kind":"fail","message":{"text":"no Go files in /home/melnik/krew"},"locations":[{"physicalLocation":{"artifactLocation":{"uriBaseId":"%SRCROOT%"},"region":{"startLine":0,"startColumn":0}}}],"suppressions":[]}],"invocations":[{"arguments":["-f","sarif","."],"workingDirectory":{"uri":"file:///home/melnik/krew"},"executionSuccessful":true}]}]}
